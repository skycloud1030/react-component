(this.webpackJsonp=this.webpackJsonp||[]).push([[7],{627:function(module,exports,__webpack_require__){eval("var api = __webpack_require__(78);\n            var content = __webpack_require__(628);\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\nvar exported = content.locals ? content.locals : {};\n\n\n\nmodule.exports = exported;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3d3dy9jb21wb25lbnQvc25hcHNob3Qvd2ViLXJ0Yy5jc3NtP2YwZGIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LTEhLi93ZWItcnRjLmNzc21cIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cbnZhciBleHBvcnRlZCA9IGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB7fTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZWQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///627\n")},628:function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(79);\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, ".web-rtc__video___1_1no {\\n  display: none;\\n}\\n", ""]);\n// Exports\nexports.locals = {\n\t"video": "web-rtc__video___1_1no"\n};\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3d3dy9jb21wb25lbnQvc25hcHNob3Qvd2ViLXJ0Yy5jc3NtPzNmMmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi53ZWItcnRjX192aWRlb19fXzFfMW5vIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJ2aWRlb1wiOiBcIndlYi1ydGNfX3ZpZGVvX19fMV8xbm9cIlxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///628\n')},640:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/antd/lib/back-top/index.js\nvar back_top = __webpack_require__(431);\nvar back_top_default = /*#__PURE__*/__webpack_require__.n(back_top);\n\n// EXTERNAL MODULE: ./node_modules/antd/lib/card/index.js\nvar card = __webpack_require__(419);\nvar card_default = /*#__PURE__*/__webpack_require__.n(card);\n\n// EXTERNAL MODULE: ./node_modules/antd/lib/slider/index.js\nvar slider = __webpack_require__(629);\nvar slider_default = /*#__PURE__*/__webpack_require__.n(slider);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js\nvar slicedToArray = __webpack_require__(109);\nvar slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);\n\n// EXTERNAL MODULE: external "React"\nvar external_React_ = __webpack_require__(0);\nvar external_React_default = /*#__PURE__*/__webpack_require__.n(external_React_);\n\n// EXTERNAL MODULE: ./node_modules/react-hooks/useMediaDevices.js\nvar useMediaDevices = __webpack_require__(626);\n\n// EXTERNAL MODULE: ./src/www/component/snapshot/web-rtc.cssm\nvar web_rtc = __webpack_require__(627);\nvar web_rtc_default = /*#__PURE__*/__webpack_require__.n(web_rtc);\n\n// CONCATENATED MODULE: ./src/www/component/snapshot/web-rtc.js\n\n\n\n\nfunction WebRTC(props, ref) {\n  var video_ref = Object(external_React_["useRef"])();\n  var video_ready = Object(useMediaDevices["a" /* default */])(video_ref);\n  Object(external_React_["useEffect"])(function () {\n    if (video_ready) {\n      var video = video_ref.current;\n      props.oncanplay(video);\n    }\n  }, [video_ready]);\n  return external_React_default.a.createElement("video", {\n    autoPlay: true,\n    muted: true,\n    ref: video_ref,\n    className: web_rtc_default.a.video\n  });\n}\n\n/* harmony default export */ var snapshot_web_rtc = (external_React_default.a.memo(external_React_default.a.forwardRef(WebRTC)));\n// CONCATENATED MODULE: ./src/components/pico/pico.js\n/* This library is released under the MIT license, see https://github.com/tehnokv/picojs */\nvar pico = {};\n\npico.unpack_cascade = function (bytes) {\n  //\n  var dview = new DataView(new ArrayBuffer(4));\n  /*\n  we skip the first 8 bytes of the cascade file\n  (cascade version number and some data used during the learning process)\n  */\n\n  var p = 8;\n  /*\n  read the depth (size) of each tree first: a 32-bit signed integer\n  */\n\n  dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n  var tdepth = dview.getInt32(0, true);\n  p = p + 4;\n  /*\n  next, read the number of trees in the cascade: another 32-bit signed integer\n  */\n\n  dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n  var ntrees = dview.getInt32(0, true);\n  p = p + 4;\n  /*\n  read the actual trees and cascade thresholds\n  */\n\n  var tcodes_ls = [];\n  var tpreds_ls = [];\n  var thresh_ls = [];\n\n  for (var t = 0; t < ntrees; ++t) {\n    // read the binary tests placed in internal tree nodes\n    Array.prototype.push.apply(tcodes_ls, [0, 0, 0, 0]);\n    Array.prototype.push.apply(tcodes_ls, bytes.slice(p, p + 4 * Math.pow(2, tdepth) - 4));\n    p = p + 4 * Math.pow(2, tdepth) - 4; // read the prediction in the leaf nodes of the tree\n\n    for (var i = 0; i < Math.pow(2, tdepth); ++i) {\n      dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n      tpreds_ls.push(dview.getFloat32(0, true));\n      p = p + 4;\n    } // read the threshold\n\n\n    dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n    thresh_ls.push(dview.getFloat32(0, true));\n    p = p + 4;\n  }\n\n  var tcodes = new Int8Array(tcodes_ls);\n  var tpreds = new Float32Array(tpreds_ls);\n  var thresh = new Float32Array(thresh_ls);\n  /*\n  construct the classification function from the read data\n  */\n\n  function classify_region(r, c, s, pixels, ldim) {\n    r = 256 * r;\n    c = 256 * c;\n    var root = 0;\n    var o = 0.0;\n    var pow2tdepth = Math.pow(2, tdepth) >> 0; // \'>>0\' transforms this number to int\n\n    for (var _i = 0; _i < ntrees; ++_i) {\n      var idx = 1;\n\n      for (var j = 0; j < tdepth; ++j) {\n        // we use \'>> 8\' here to perform an integer division: this seems important for performance\n        idx = 2 * idx + (pixels[(r + tcodes[root + 4 * idx + 0] * s >> 8) * ldim + (c + tcodes[root + 4 * idx + 1] * s >> 8)] <= pixels[(r + tcodes[root + 4 * idx + 2] * s >> 8) * ldim + (c + tcodes[root + 4 * idx + 3] * s >> 8)]);\n      }\n\n      o = o + tpreds[pow2tdepth * _i + idx - pow2tdepth];\n      if (o <= thresh[_i]) return -1;\n      root += 4 * pow2tdepth;\n    }\n\n    return o - thresh[ntrees - 1];\n  }\n  /*\n  we\'re done\n  */\n\n\n  return classify_region;\n};\n\npico.run_cascade = function (image, classify_region, params) {\n  var pixels = image.pixels;\n  var nrows = image.nrows;\n  var ncols = image.ncols;\n  var ldim = image.ldim;\n  var shiftfactor = params.shiftfactor;\n  var minsize = params.minsize;\n  var maxsize = params.maxsize;\n  var scalefactor = params.scalefactor;\n  var scale = minsize;\n  var detections = [];\n\n  while (scale <= maxsize) {\n    var step = Math.max(shiftfactor * scale, 1) >> 0; // \'>>0\' transforms this number to int\n\n    var offset = scale / 2 + 1 >> 0;\n\n    for (var r = offset; r <= nrows - offset; r += step) {\n      for (var c = offset; c <= ncols - offset; c += step) {\n        var q = classify_region(r, c, scale, pixels, ldim);\n        if (q > 0.0) detections.push([r, c, scale, q]);\n      }\n    }\n\n    scale = scale * scalefactor;\n  }\n\n  return detections;\n};\n\npico.cluster_detections = function (dets, iouthreshold) {\n  /*\n  sort detections by their score\n  */\n  dets = dets.sort(function (a, b) {\n    return b[3] - a[3];\n  });\n  /*\n  this helper function calculates the intersection over union for two detections\n  */\n\n  function calculate_iou(det1, det2) {\n    // unpack the position and size of each detection\n    var r1 = det1[0],\n        c1 = det1[1],\n        s1 = det1[2];\n    var r2 = det2[0],\n        c2 = det2[1],\n        s2 = det2[2]; // calculate detection overlap in each dimension\n\n    var overr = Math.max(0, Math.min(r1 + s1 / 2, r2 + s2 / 2) - Math.max(r1 - s1 / 2, r2 - s2 / 2));\n    var overc = Math.max(0, Math.min(c1 + s1 / 2, c2 + s2 / 2) - Math.max(c1 - s1 / 2, c2 - s2 / 2)); // calculate and return IoU\n\n    return overr * overc / (s1 * s1 + s2 * s2 - overr * overc);\n  }\n  /*\n  do clustering through non-maximum suppression\n  */\n\n\n  var assignments = new Array(dets.length).fill(0);\n  var clusters = [];\n\n  for (var i = 0; i < dets.length; ++i) {\n    // is this detection assigned to a cluster?\n    if (assignments[i] == 0) {\n      // it is not:\n      // now we make a cluster out of it and see whether some other detections belong to it\n      var r = 0.0,\n          c = 0.0,\n          s = 0.0,\n          q = 0.0,\n          n = 0;\n\n      for (var j = i; j < dets.length; ++j) {\n        if (calculate_iou(dets[i], dets[j]) > iouthreshold) {\n          assignments[j] = 1;\n          r = r + dets[j][0];\n          c = c + dets[j][1];\n          s = s + dets[j][2];\n          q = q + dets[j][3];\n          n = n + 1;\n        }\n      } // make a cluster representative\n\n\n      clusters.push([r / n, c / n, s / n, q]);\n    }\n  }\n\n  return clusters;\n};\n\npico.instantiate_detection_memory = function (size) {\n  /*\n  initialize a circular buffer of `size` elements\n  */\n  var n = 0;\n  var memory = [];\n\n  for (var i = 0; i < size; ++i) {\n    memory.push([]);\n  }\n  /*\n  build a function that:\n  (1) inserts the current frame\'s detections into the buffer;\n  (2) merges all detections from the last `size` frames and returns them\n  */\n\n\n  function update_memory(dets) {\n    memory[n] = dets;\n    n = (n + 1) % memory.length;\n    dets = [];\n\n    for (var _i2 = 0; _i2 < memory.length; ++_i2) {\n      dets = dets.concat(memory[_i2]);\n    } //\n\n\n    return dets;\n  }\n  /*\n  we\'re done\n  */\n\n\n  return update_memory;\n};\n\n/* harmony default export */ var pico_pico = (pico);\n// CONCATENATED MODULE: ./src/components/pico/lploc.js\n\n\n/* This library is released under the MIT license, contact @tehnokv for more details */\nvar lploc = {};\n\nlploc.unpack_localizer = function (bytes) {\n  //\n  var dview = new DataView(new ArrayBuffer(4));\n  var p = 0;\n  /*\n  read the number of stages, scale multiplier (applied after each stage),\n  number of trees per stage and depth of each tree\n  */\n\n  dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n  var nstages = dview.getInt32(0, true);\n  p = p + 4;\n  dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n  var scalemul = dview.getFloat32(0, true);\n  p = p + 4;\n  dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n  var ntreesperstage = dview.getInt32(0, true);\n  p = p + 4;\n  dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n  var tdepth = dview.getInt32(0, true);\n  p = p + 4;\n  /*\n  unpack the trees\n  */\n\n  var tcodes_ls = [];\n  var tpreds_ls = [];\n\n  for (var i = 0; i < nstages; ++i) {\n    // read the trees for this stage\n    for (var j = 0; j < ntreesperstage; ++j) {\n      // binary tests (we can read all of them at once)\n      Array.prototype.push.apply(tcodes_ls, bytes.slice(p, p + 4 * Math.pow(2, tdepth) - 4));\n      p = p + 4 * Math.pow(2, tdepth) - 4; // read the prediction in the leaf nodes of the tree\n\n      for (var k = 0; k < Math.pow(2, tdepth); ++k) {\n        for (var l = 0; l < 2; ++l) {\n          dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n          tpreds_ls.push(dview.getFloat32(0, true));\n          p = p + 4;\n        }\n      }\n    }\n  }\n\n  var tcodes = new Int8Array(tcodes_ls);\n  var tpreds = new Float32Array(tpreds_ls);\n  /*\n  construct the location estimaton function\n  */\n\n  function loc_fun(r, c, s, pixels, nrows, ncols, ldim) {\n    var root = 0;\n    var pow2tdepth = Math.pow(2, tdepth) >> 0; // \'>>0\' transforms this number to int\n\n    for (var _i = 0; _i < nstages; ++_i) {\n      var dr = 0.0,\n          dc = 0.0;\n\n      for (var _j = 0; _j < ntreesperstage; ++_j) {\n        var idx = 0;\n\n        for (var _k = 0; _k < tdepth; ++_k) {\n          var r1 = Math.min(nrows - 1, Math.max(0, 256 * r + tcodes[root + 4 * idx + 0] * s >> 8));\n          var c1 = Math.min(ncols - 1, Math.max(0, 256 * c + tcodes[root + 4 * idx + 1] * s >> 8));\n          var r2 = Math.min(nrows - 1, Math.max(0, 256 * r + tcodes[root + 4 * idx + 2] * s >> 8));\n          var c2 = Math.min(ncols - 1, Math.max(0, 256 * c + tcodes[root + 4 * idx + 3] * s >> 8));\n          idx = 2 * idx + 1 + (pixels[r1 * ldim + c1] > pixels[r2 * ldim + c2]);\n        }\n\n        var lutidx = 2 * (ntreesperstage * pow2tdepth * _i + pow2tdepth * _j + idx - (pow2tdepth - 1));\n        dr += tpreds[lutidx + 0];\n        dc += tpreds[lutidx + 1];\n        root += 4 * pow2tdepth - 4;\n      }\n\n      r = r + dr * s;\n      c = c + dc * s;\n      s = s * scalemul;\n    }\n\n    return [r, c];\n  }\n  /*\n  this function applies random perturbations to the default rectangle (r, c, s)\n  */\n\n\n  function loc_fun_with_perturbs(r, c, s, nperturbs, image) {\n    var rows = [],\n        cols = [];\n\n    for (var _i2 = 0; _i2 < nperturbs; ++_i2) {\n      var _s = s * (0.925 + 0.15 * Math.random());\n\n      var _r = r + s * 0.15 * (0.5 - Math.random());\n\n      var _c = c + s * 0.15 * (0.5 - Math.random());\n\n      var _loc_fun = loc_fun(_r, _c, _s, image.pixels, image.nrows, image.ncols, image.ldim);\n\n      var _loc_fun2 = slicedToArray_default()(_loc_fun, 2);\n\n      _r = _loc_fun2[0];\n      _c = _loc_fun2[1];\n      rows.push(_r);\n      cols.push(_c);\n    } // return the median along each axis\n\n\n    rows.sort();\n    cols.sort();\n    return [rows[Math.round(nperturbs / 2)], cols[Math.round(nperturbs / 2)]];\n  }\n  /*\n  we\'re done\n  */\n\n\n  return loc_fun_with_perturbs;\n};\n\n/* harmony default export */ var pico_lploc = (lploc);\n// CONCATENATED MODULE: ./src/components/pico/utility/index.js\nfunction rgba_to_grayscale(rgba, nrows, ncols) {\n  var gray = new Uint8Array(nrows * ncols);\n\n  for (var r = 0; r < nrows; ++r) {\n    for (var c = 0; c < ncols; ++c) {\n      // gray = 0.2*red + 0.7*green + 0.1*blue\n      gray[r * ncols + c] = (2 * rgba[r * 4 * ncols + 4 * c + 0] + 7 * rgba[r * 4 * ncols + 4 * c + 1] + 1 * rgba[r * 4 * ncols + 4 * c + 2]) / 10;\n    }\n  }\n\n  return gray;\n}\nfunction canvas_to_image(canvas) {\n  var img = canvas.toDataURL();\n  return img;\n}\n// CONCATENATED MODULE: ./src/www/component/snapshot/pico-detect.js\n\n\n\n\n\n\nfunction Pico(props) {\n  var video = props.video,\n      _props$score = props.score,\n      score = _props$score === void 0 ? 100 : _props$score;\n  var ctx_ref = Object(external_React_["useRef"])(null);\n  var score_ref = Object(external_React_["useRef"])(score);\n  Object(external_React_["useEffect"])(function () {\n    score_ref.current = score;\n  }, [score]);\n  Object(external_React_["useEffect"])(function () {\n    if (video) {\n      var cancel = false;\n      var ctx = ctx_ref.current.getContext("2d");\n      var update_memory = pico_pico.instantiate_detection_memory(5);\n      var fetch_puploc = fetch("./data/puploc.bin").then(function (response) {\n        return response.arrayBuffer();\n      }).then(function (buffer) {\n        return pico_lploc.unpack_localizer(new Int8Array(buffer));\n      });\n      var fetch_face = fetch("./data/facefinder").then(function (response) {\n        return response.arrayBuffer();\n      }).then(function (buffer) {\n        return pico_pico.unpack_cascade(new Int8Array(buffer));\n      });\n      var params = {\n        shiftfactor: 0.1,\n        // move the detection window by 10% of its size\n        minsize: 100,\n        // minimum size of a face\n        maxsize: 1000,\n        // maximum size of a face\n        scalefactor: 1.1 // for multiscale processing: resize the detection window by 10% when moving to the higher scale\n\n      };\n      Promise.all([fetch_face, fetch_puploc]).then(function (_ref) {\n        var _ref2 = slicedToArray_default()(_ref, 2),\n            facefinder_classify_region = _ref2[0],\n            do_puploc = _ref2[1];\n\n        function getVideoFrame() {\n          if (cancel) {\n            return;\n          }\n\n          ctx.drawImage(video, 0, 0);\n          var rgba = ctx.getImageData(0, 0, 640, 480).data;\n          var image = {\n            pixels: rgba_to_grayscale(rgba, 480, 640),\n            nrows: 480,\n            ncols: 640,\n            ldim: 640\n          };\n          var dets = pico_pico.run_cascade(image, facefinder_classify_region, params);\n          dets = update_memory(dets);\n          dets = pico_pico.cluster_detections(dets, 0.2); // set IoU threshold to 0.2\n\n          for (var i = 0; i < dets.length; ++i) {\n            if (dets[i][3] > score_ref.current) {\n              ctx.beginPath();\n              ctx.arc(dets[i][1], dets[i][0], dets[i][2] / 2, 0, 2 * Math.PI, false);\n              ctx.lineWidth = 3;\n              ctx.strokeStyle = "red";\n              ctx.stroke();\n              var r = dets[i][0] - 0.075 * dets[i][2];\n              var c = dets[i][1] - 0.175 * dets[i][2];\n              var s = 0.35 * dets[i][2];\n\n              var _do_puploc = do_puploc(r, c, s, 63, image);\n\n              var _do_puploc2 = slicedToArray_default()(_do_puploc, 2);\n\n              r = _do_puploc2[0];\n              c = _do_puploc2[1];\n\n              if (r >= 0 && c >= 0) {\n                ctx.beginPath();\n                ctx.arc(c, r, 1, 0, 2 * Math.PI, false);\n                ctx.lineWidth = 3;\n                ctx.strokeStyle = "red";\n                ctx.stroke();\n              }\n\n              r = dets[i][0] - 0.075 * dets[i][2];\n              c = dets[i][1] + 0.175 * dets[i][2];\n              s = 0.35 * dets[i][2];\n\n              var _do_puploc3 = do_puploc(r, c, s, 63, image);\n\n              var _do_puploc4 = slicedToArray_default()(_do_puploc3, 2);\n\n              r = _do_puploc4[0];\n              c = _do_puploc4[1];\n\n              if (r >= 0 && c >= 0) {\n                ctx.beginPath();\n                ctx.arc(c, r, 1, 0, 2 * Math.PI, false);\n                ctx.lineWidth = 3;\n                ctx.strokeStyle = "red";\n                ctx.stroke();\n              }\n            }\n          }\n\n          requestAnimationFrame(function () {\n            return getVideoFrame();\n          });\n        }\n\n        getVideoFrame();\n      });\n      return function () {\n        cancel = true;\n      };\n    }\n  }, [video]);\n  return external_React_default.a.createElement("canvas", {\n    width: 640,\n    height: 480,\n    ref: ctx_ref\n  });\n}\n\n/* harmony default export */ var pico_detect = (external_React_default.a.memo(Pico));\n// CONCATENATED MODULE: ./src/www/component/snapshot/index.js\n\n\n\n\n\n\n\n\nfunction FaceDetect() {\n  var _useState = Object(external_React_["useState"])(100),\n      _useState2 = slicedToArray_default()(_useState, 2),\n      score = _useState2[0],\n      setScore = _useState2[1];\n\n  var _useState3 = Object(external_React_["useState"])(),\n      _useState4 = slicedToArray_default()(_useState3, 2),\n      video = _useState4[0],\n      setVideo = _useState4[1];\n\n  var onAfterChange = Object(external_React_["useCallback"])(function (val) {\n    setImg([]);\n    setScore(val);\n  }, []);\n  var oncanplay = Object(external_React_["useCallback"])(function (video) {\n    setVideo(video);\n  }, []);\n  return external_React_default.a.createElement(external_React_default.a.Fragment, null, external_React_default.a.createElement(card_default.a, {\n    style: {\n      marginBottom: 24\n    }\n  }, "Accuracy:", external_React_default.a.createElement(slider_default.a, {\n    defaultValue: score,\n    max: 500,\n    min: 50,\n    marks: {\n      500: "500",\n      50: "50"\n    },\n    onAfterChange: onAfterChange,\n    style: {\n      width: 200\n    }\n  }), external_React_default.a.createElement("div", {\n    style: {\n      marginTop: 40\n    }\n  }, external_React_default.a.createElement(snapshot_web_rtc, {\n    oncanplay: oncanplay\n  }), external_React_default.a.createElement(pico_detect, {\n    video: video,\n    score: score\n  }))), external_React_default.a.createElement(back_top_default.a, null));\n}\n\n/* harmony default export */ var snapshot = __webpack_exports__["default"] = (external_React_default.a.memo(FaceDetect));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3d3dy9jb21wb25lbnQvc25hcHNob3Qvd2ViLXJ0Yy5qcz82NjNmIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3BpY28vcGljby5qcz9lZDNhIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3BpY28vbHBsb2MuanM/NGZlYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9waWNvL3V0aWxpdHkvaW5kZXguanM/MDJiYSIsIndlYnBhY2s6Ly8vLi9zcmMvd3d3L2NvbXBvbmVudC9zbmFwc2hvdC9waWNvLWRldGVjdC5qcz9lMmNiIiwid2VicGFjazovLy8uL3NyYy93d3cvY29tcG9uZW50L3NuYXBzaG90L2luZGV4LmpzPzZhMjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdXNlTWVkaWFEZXZpY2VzIGZyb20gXCJyZWFjdC1ob29rcy91c2VNZWRpYURldmljZXMuanNcIjtcbmltcG9ydCBzdHlsZXMgZnJvbSBcIi4vd2ViLXJ0Yy5jc3NtXCI7XG5cbmZ1bmN0aW9uIFdlYlJUQyhwcm9wcywgcmVmKSB7XG4gIHZhciB2aWRlb19yZWYgPSB1c2VSZWYoKTtcbiAgdmFyIHZpZGVvX3JlYWR5ID0gdXNlTWVkaWFEZXZpY2VzKHZpZGVvX3JlZik7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHZpZGVvX3JlYWR5KSB7XG4gICAgICB2YXIgdmlkZW8gPSB2aWRlb19yZWYuY3VycmVudDtcbiAgICAgIHByb3BzLm9uY2FucGxheSh2aWRlbyk7XG4gICAgfVxuICB9LCBbdmlkZW9fcmVhZHldKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiLCB7XG4gICAgYXV0b1BsYXk6IHRydWUsXG4gICAgbXV0ZWQ6IHRydWUsXG4gICAgcmVmOiB2aWRlb19yZWYsXG4gICAgY2xhc3NOYW1lOiBzdHlsZXMudmlkZW9cbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlYWN0Lm1lbW8oUmVhY3QuZm9yd2FyZFJlZihXZWJSVEMpKTsiLCIvKiBUaGlzIGxpYnJhcnkgaXMgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RlaG5va3YvcGljb2pzICovXG52YXIgcGljbyA9IHt9O1xuXG5waWNvLnVucGFja19jYXNjYWRlID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gIC8vXG4gIHZhciBkdmlldyA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoNCkpO1xuICAvKlxuICB3ZSBza2lwIHRoZSBmaXJzdCA4IGJ5dGVzIG9mIHRoZSBjYXNjYWRlIGZpbGVcbiAgKGNhc2NhZGUgdmVyc2lvbiBudW1iZXIgYW5kIHNvbWUgZGF0YSB1c2VkIGR1cmluZyB0aGUgbGVhcm5pbmcgcHJvY2VzcylcbiAgKi9cblxuICB2YXIgcCA9IDg7XG4gIC8qXG4gIHJlYWQgdGhlIGRlcHRoIChzaXplKSBvZiBlYWNoIHRyZWUgZmlyc3Q6IGEgMzItYml0IHNpZ25lZCBpbnRlZ2VyXG4gICovXG5cbiAgZHZpZXcuc2V0VWludDgoMCwgYnl0ZXNbcCArIDBdKSwgZHZpZXcuc2V0VWludDgoMSwgYnl0ZXNbcCArIDFdKSwgZHZpZXcuc2V0VWludDgoMiwgYnl0ZXNbcCArIDJdKSwgZHZpZXcuc2V0VWludDgoMywgYnl0ZXNbcCArIDNdKTtcbiAgdmFyIHRkZXB0aCA9IGR2aWV3LmdldEludDMyKDAsIHRydWUpO1xuICBwID0gcCArIDQ7XG4gIC8qXG4gIG5leHQsIHJlYWQgdGhlIG51bWJlciBvZiB0cmVlcyBpbiB0aGUgY2FzY2FkZTogYW5vdGhlciAzMi1iaXQgc2lnbmVkIGludGVnZXJcbiAgKi9cblxuICBkdmlldy5zZXRVaW50OCgwLCBieXRlc1twICsgMF0pLCBkdmlldy5zZXRVaW50OCgxLCBieXRlc1twICsgMV0pLCBkdmlldy5zZXRVaW50OCgyLCBieXRlc1twICsgMl0pLCBkdmlldy5zZXRVaW50OCgzLCBieXRlc1twICsgM10pO1xuICB2YXIgbnRyZWVzID0gZHZpZXcuZ2V0SW50MzIoMCwgdHJ1ZSk7XG4gIHAgPSBwICsgNDtcbiAgLypcbiAgcmVhZCB0aGUgYWN0dWFsIHRyZWVzIGFuZCBjYXNjYWRlIHRocmVzaG9sZHNcbiAgKi9cblxuICB2YXIgdGNvZGVzX2xzID0gW107XG4gIHZhciB0cHJlZHNfbHMgPSBbXTtcbiAgdmFyIHRocmVzaF9scyA9IFtdO1xuXG4gIGZvciAodmFyIHQgPSAwOyB0IDwgbnRyZWVzOyArK3QpIHtcbiAgICAvLyByZWFkIHRoZSBiaW5hcnkgdGVzdHMgcGxhY2VkIGluIGludGVybmFsIHRyZWUgbm9kZXNcbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0Y29kZXNfbHMsIFswLCAwLCAwLCAwXSk7XG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGNvZGVzX2xzLCBieXRlcy5zbGljZShwLCBwICsgNCAqIE1hdGgucG93KDIsIHRkZXB0aCkgLSA0KSk7XG4gICAgcCA9IHAgKyA0ICogTWF0aC5wb3coMiwgdGRlcHRoKSAtIDQ7IC8vIHJlYWQgdGhlIHByZWRpY3Rpb24gaW4gdGhlIGxlYWYgbm9kZXMgb2YgdGhlIHRyZWVcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5wb3coMiwgdGRlcHRoKTsgKytpKSB7XG4gICAgICBkdmlldy5zZXRVaW50OCgwLCBieXRlc1twICsgMF0pLCBkdmlldy5zZXRVaW50OCgxLCBieXRlc1twICsgMV0pLCBkdmlldy5zZXRVaW50OCgyLCBieXRlc1twICsgMl0pLCBkdmlldy5zZXRVaW50OCgzLCBieXRlc1twICsgM10pO1xuICAgICAgdHByZWRzX2xzLnB1c2goZHZpZXcuZ2V0RmxvYXQzMigwLCB0cnVlKSk7XG4gICAgICBwID0gcCArIDQ7XG4gICAgfSAvLyByZWFkIHRoZSB0aHJlc2hvbGRcblxuXG4gICAgZHZpZXcuc2V0VWludDgoMCwgYnl0ZXNbcCArIDBdKSwgZHZpZXcuc2V0VWludDgoMSwgYnl0ZXNbcCArIDFdKSwgZHZpZXcuc2V0VWludDgoMiwgYnl0ZXNbcCArIDJdKSwgZHZpZXcuc2V0VWludDgoMywgYnl0ZXNbcCArIDNdKTtcbiAgICB0aHJlc2hfbHMucHVzaChkdmlldy5nZXRGbG9hdDMyKDAsIHRydWUpKTtcbiAgICBwID0gcCArIDQ7XG4gIH1cblxuICB2YXIgdGNvZGVzID0gbmV3IEludDhBcnJheSh0Y29kZXNfbHMpO1xuICB2YXIgdHByZWRzID0gbmV3IEZsb2F0MzJBcnJheSh0cHJlZHNfbHMpO1xuICB2YXIgdGhyZXNoID0gbmV3IEZsb2F0MzJBcnJheSh0aHJlc2hfbHMpO1xuICAvKlxuICBjb25zdHJ1Y3QgdGhlIGNsYXNzaWZpY2F0aW9uIGZ1bmN0aW9uIGZyb20gdGhlIHJlYWQgZGF0YVxuICAqL1xuXG4gIGZ1bmN0aW9uIGNsYXNzaWZ5X3JlZ2lvbihyLCBjLCBzLCBwaXhlbHMsIGxkaW0pIHtcbiAgICByID0gMjU2ICogcjtcbiAgICBjID0gMjU2ICogYztcbiAgICB2YXIgcm9vdCA9IDA7XG4gICAgdmFyIG8gPSAwLjA7XG4gICAgdmFyIHBvdzJ0ZGVwdGggPSBNYXRoLnBvdygyLCB0ZGVwdGgpID4+IDA7IC8vICc+PjAnIHRyYW5zZm9ybXMgdGhpcyBudW1iZXIgdG8gaW50XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbnRyZWVzOyArK19pKSB7XG4gICAgICB2YXIgaWR4ID0gMTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0ZGVwdGg7ICsraikge1xuICAgICAgICAvLyB3ZSB1c2UgJz4+IDgnIGhlcmUgdG8gcGVyZm9ybSBhbiBpbnRlZ2VyIGRpdmlzaW9uOiB0aGlzIHNlZW1zIGltcG9ydGFudCBmb3IgcGVyZm9ybWFuY2VcbiAgICAgICAgaWR4ID0gMiAqIGlkeCArIChwaXhlbHNbKHIgKyB0Y29kZXNbcm9vdCArIDQgKiBpZHggKyAwXSAqIHMgPj4gOCkgKiBsZGltICsgKGMgKyB0Y29kZXNbcm9vdCArIDQgKiBpZHggKyAxXSAqIHMgPj4gOCldIDw9IHBpeGVsc1sociArIHRjb2Rlc1tyb290ICsgNCAqIGlkeCArIDJdICogcyA+PiA4KSAqIGxkaW0gKyAoYyArIHRjb2Rlc1tyb290ICsgNCAqIGlkeCArIDNdICogcyA+PiA4KV0pO1xuICAgICAgfVxuXG4gICAgICBvID0gbyArIHRwcmVkc1twb3cydGRlcHRoICogX2kgKyBpZHggLSBwb3cydGRlcHRoXTtcbiAgICAgIGlmIChvIDw9IHRocmVzaFtfaV0pIHJldHVybiAtMTtcbiAgICAgIHJvb3QgKz0gNCAqIHBvdzJ0ZGVwdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG8gLSB0aHJlc2hbbnRyZWVzIC0gMV07XG4gIH1cbiAgLypcbiAgd2UncmUgZG9uZVxuICAqL1xuXG5cbiAgcmV0dXJuIGNsYXNzaWZ5X3JlZ2lvbjtcbn07XG5cbnBpY28ucnVuX2Nhc2NhZGUgPSBmdW5jdGlvbiAoaW1hZ2UsIGNsYXNzaWZ5X3JlZ2lvbiwgcGFyYW1zKSB7XG4gIHZhciBwaXhlbHMgPSBpbWFnZS5waXhlbHM7XG4gIHZhciBucm93cyA9IGltYWdlLm5yb3dzO1xuICB2YXIgbmNvbHMgPSBpbWFnZS5uY29scztcbiAgdmFyIGxkaW0gPSBpbWFnZS5sZGltO1xuICB2YXIgc2hpZnRmYWN0b3IgPSBwYXJhbXMuc2hpZnRmYWN0b3I7XG4gIHZhciBtaW5zaXplID0gcGFyYW1zLm1pbnNpemU7XG4gIHZhciBtYXhzaXplID0gcGFyYW1zLm1heHNpemU7XG4gIHZhciBzY2FsZWZhY3RvciA9IHBhcmFtcy5zY2FsZWZhY3RvcjtcbiAgdmFyIHNjYWxlID0gbWluc2l6ZTtcbiAgdmFyIGRldGVjdGlvbnMgPSBbXTtcblxuICB3aGlsZSAoc2NhbGUgPD0gbWF4c2l6ZSkge1xuICAgIHZhciBzdGVwID0gTWF0aC5tYXgoc2hpZnRmYWN0b3IgKiBzY2FsZSwgMSkgPj4gMDsgLy8gJz4+MCcgdHJhbnNmb3JtcyB0aGlzIG51bWJlciB0byBpbnRcblxuICAgIHZhciBvZmZzZXQgPSBzY2FsZSAvIDIgKyAxID4+IDA7XG5cbiAgICBmb3IgKHZhciByID0gb2Zmc2V0OyByIDw9IG5yb3dzIC0gb2Zmc2V0OyByICs9IHN0ZXApIHtcbiAgICAgIGZvciAodmFyIGMgPSBvZmZzZXQ7IGMgPD0gbmNvbHMgLSBvZmZzZXQ7IGMgKz0gc3RlcCkge1xuICAgICAgICB2YXIgcSA9IGNsYXNzaWZ5X3JlZ2lvbihyLCBjLCBzY2FsZSwgcGl4ZWxzLCBsZGltKTtcbiAgICAgICAgaWYgKHEgPiAwLjApIGRldGVjdGlvbnMucHVzaChbciwgYywgc2NhbGUsIHFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2FsZSA9IHNjYWxlICogc2NhbGVmYWN0b3I7XG4gIH1cblxuICByZXR1cm4gZGV0ZWN0aW9ucztcbn07XG5cbnBpY28uY2x1c3Rlcl9kZXRlY3Rpb25zID0gZnVuY3Rpb24gKGRldHMsIGlvdXRocmVzaG9sZCkge1xuICAvKlxuICBzb3J0IGRldGVjdGlvbnMgYnkgdGhlaXIgc2NvcmVcbiAgKi9cbiAgZGV0cyA9IGRldHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiWzNdIC0gYVszXTtcbiAgfSk7XG4gIC8qXG4gIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIGludGVyc2VjdGlvbiBvdmVyIHVuaW9uIGZvciB0d28gZGV0ZWN0aW9uc1xuICAqL1xuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZV9pb3UoZGV0MSwgZGV0Mikge1xuICAgIC8vIHVucGFjayB0aGUgcG9zaXRpb24gYW5kIHNpemUgb2YgZWFjaCBkZXRlY3Rpb25cbiAgICB2YXIgcjEgPSBkZXQxWzBdLFxuICAgICAgICBjMSA9IGRldDFbMV0sXG4gICAgICAgIHMxID0gZGV0MVsyXTtcbiAgICB2YXIgcjIgPSBkZXQyWzBdLFxuICAgICAgICBjMiA9IGRldDJbMV0sXG4gICAgICAgIHMyID0gZGV0MlsyXTsgLy8gY2FsY3VsYXRlIGRldGVjdGlvbiBvdmVybGFwIGluIGVhY2ggZGltZW5zaW9uXG5cbiAgICB2YXIgb3ZlcnIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyMSArIHMxIC8gMiwgcjIgKyBzMiAvIDIpIC0gTWF0aC5tYXgocjEgLSBzMSAvIDIsIHIyIC0gczIgLyAyKSk7XG4gICAgdmFyIG92ZXJjID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYzEgKyBzMSAvIDIsIGMyICsgczIgLyAyKSAtIE1hdGgubWF4KGMxIC0gczEgLyAyLCBjMiAtIHMyIC8gMikpOyAvLyBjYWxjdWxhdGUgYW5kIHJldHVybiBJb1VcblxuICAgIHJldHVybiBvdmVyciAqIG92ZXJjIC8gKHMxICogczEgKyBzMiAqIHMyIC0gb3ZlcnIgKiBvdmVyYyk7XG4gIH1cbiAgLypcbiAgZG8gY2x1c3RlcmluZyB0aHJvdWdoIG5vbi1tYXhpbXVtIHN1cHByZXNzaW9uXG4gICovXG5cblxuICB2YXIgYXNzaWdubWVudHMgPSBuZXcgQXJyYXkoZGV0cy5sZW5ndGgpLmZpbGwoMCk7XG4gIHZhciBjbHVzdGVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGV0cy5sZW5ndGg7ICsraSkge1xuICAgIC8vIGlzIHRoaXMgZGV0ZWN0aW9uIGFzc2lnbmVkIHRvIGEgY2x1c3Rlcj9cbiAgICBpZiAoYXNzaWdubWVudHNbaV0gPT0gMCkge1xuICAgICAgLy8gaXQgaXMgbm90OlxuICAgICAgLy8gbm93IHdlIG1ha2UgYSBjbHVzdGVyIG91dCBvZiBpdCBhbmQgc2VlIHdoZXRoZXIgc29tZSBvdGhlciBkZXRlY3Rpb25zIGJlbG9uZyB0byBpdFxuICAgICAgdmFyIHIgPSAwLjAsXG4gICAgICAgICAgYyA9IDAuMCxcbiAgICAgICAgICBzID0gMC4wLFxuICAgICAgICAgIHEgPSAwLjAsXG4gICAgICAgICAgbiA9IDA7XG5cbiAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgZGV0cy5sZW5ndGg7ICsraikge1xuICAgICAgICBpZiAoY2FsY3VsYXRlX2lvdShkZXRzW2ldLCBkZXRzW2pdKSA+IGlvdXRocmVzaG9sZCkge1xuICAgICAgICAgIGFzc2lnbm1lbnRzW2pdID0gMTtcbiAgICAgICAgICByID0gciArIGRldHNbal1bMF07XG4gICAgICAgICAgYyA9IGMgKyBkZXRzW2pdWzFdO1xuICAgICAgICAgIHMgPSBzICsgZGV0c1tqXVsyXTtcbiAgICAgICAgICBxID0gcSArIGRldHNbal1bM107XG4gICAgICAgICAgbiA9IG4gKyAxO1xuICAgICAgICB9XG4gICAgICB9IC8vIG1ha2UgYSBjbHVzdGVyIHJlcHJlc2VudGF0aXZlXG5cblxuICAgICAgY2x1c3RlcnMucHVzaChbciAvIG4sIGMgLyBuLCBzIC8gbiwgcV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbHVzdGVycztcbn07XG5cbnBpY28uaW5zdGFudGlhdGVfZGV0ZWN0aW9uX21lbW9yeSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIC8qXG4gIGluaXRpYWxpemUgYSBjaXJjdWxhciBidWZmZXIgb2YgYHNpemVgIGVsZW1lbnRzXG4gICovXG4gIHZhciBuID0gMDtcbiAgdmFyIG1lbW9yeSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgbWVtb3J5LnB1c2goW10pO1xuICB9XG4gIC8qXG4gIGJ1aWxkIGEgZnVuY3Rpb24gdGhhdDpcbiAgKDEpIGluc2VydHMgdGhlIGN1cnJlbnQgZnJhbWUncyBkZXRlY3Rpb25zIGludG8gdGhlIGJ1ZmZlcjtcbiAgKDIpIG1lcmdlcyBhbGwgZGV0ZWN0aW9ucyBmcm9tIHRoZSBsYXN0IGBzaXplYCBmcmFtZXMgYW5kIHJldHVybnMgdGhlbVxuICAqL1xuXG5cbiAgZnVuY3Rpb24gdXBkYXRlX21lbW9yeShkZXRzKSB7XG4gICAgbWVtb3J5W25dID0gZGV0cztcbiAgICBuID0gKG4gKyAxKSAlIG1lbW9yeS5sZW5ndGg7XG4gICAgZGV0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbWVtb3J5Lmxlbmd0aDsgKytfaTIpIHtcbiAgICAgIGRldHMgPSBkZXRzLmNvbmNhdChtZW1vcnlbX2kyXSk7XG4gICAgfSAvL1xuXG5cbiAgICByZXR1cm4gZGV0cztcbiAgfVxuICAvKlxuICB3ZSdyZSBkb25lXG4gICovXG5cblxuICByZXR1cm4gdXBkYXRlX21lbW9yeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHBpY287IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXlcIjtcblxuLyogVGhpcyBsaWJyYXJ5IGlzIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgY29udGFjdCBAdGVobm9rdiBmb3IgbW9yZSBkZXRhaWxzICovXG52YXIgbHBsb2MgPSB7fTtcblxubHBsb2MudW5wYWNrX2xvY2FsaXplciA9IGZ1bmN0aW9uIChieXRlcykge1xuICAvL1xuICB2YXIgZHZpZXcgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDQpKTtcbiAgdmFyIHAgPSAwO1xuICAvKlxuICByZWFkIHRoZSBudW1iZXIgb2Ygc3RhZ2VzLCBzY2FsZSBtdWx0aXBsaWVyIChhcHBsaWVkIGFmdGVyIGVhY2ggc3RhZ2UpLFxuICBudW1iZXIgb2YgdHJlZXMgcGVyIHN0YWdlIGFuZCBkZXB0aCBvZiBlYWNoIHRyZWVcbiAgKi9cblxuICBkdmlldy5zZXRVaW50OCgwLCBieXRlc1twICsgMF0pLCBkdmlldy5zZXRVaW50OCgxLCBieXRlc1twICsgMV0pLCBkdmlldy5zZXRVaW50OCgyLCBieXRlc1twICsgMl0pLCBkdmlldy5zZXRVaW50OCgzLCBieXRlc1twICsgM10pO1xuICB2YXIgbnN0YWdlcyA9IGR2aWV3LmdldEludDMyKDAsIHRydWUpO1xuICBwID0gcCArIDQ7XG4gIGR2aWV3LnNldFVpbnQ4KDAsIGJ5dGVzW3AgKyAwXSksIGR2aWV3LnNldFVpbnQ4KDEsIGJ5dGVzW3AgKyAxXSksIGR2aWV3LnNldFVpbnQ4KDIsIGJ5dGVzW3AgKyAyXSksIGR2aWV3LnNldFVpbnQ4KDMsIGJ5dGVzW3AgKyAzXSk7XG4gIHZhciBzY2FsZW11bCA9IGR2aWV3LmdldEZsb2F0MzIoMCwgdHJ1ZSk7XG4gIHAgPSBwICsgNDtcbiAgZHZpZXcuc2V0VWludDgoMCwgYnl0ZXNbcCArIDBdKSwgZHZpZXcuc2V0VWludDgoMSwgYnl0ZXNbcCArIDFdKSwgZHZpZXcuc2V0VWludDgoMiwgYnl0ZXNbcCArIDJdKSwgZHZpZXcuc2V0VWludDgoMywgYnl0ZXNbcCArIDNdKTtcbiAgdmFyIG50cmVlc3BlcnN0YWdlID0gZHZpZXcuZ2V0SW50MzIoMCwgdHJ1ZSk7XG4gIHAgPSBwICsgNDtcbiAgZHZpZXcuc2V0VWludDgoMCwgYnl0ZXNbcCArIDBdKSwgZHZpZXcuc2V0VWludDgoMSwgYnl0ZXNbcCArIDFdKSwgZHZpZXcuc2V0VWludDgoMiwgYnl0ZXNbcCArIDJdKSwgZHZpZXcuc2V0VWludDgoMywgYnl0ZXNbcCArIDNdKTtcbiAgdmFyIHRkZXB0aCA9IGR2aWV3LmdldEludDMyKDAsIHRydWUpO1xuICBwID0gcCArIDQ7XG4gIC8qXG4gIHVucGFjayB0aGUgdHJlZXNcbiAgKi9cblxuICB2YXIgdGNvZGVzX2xzID0gW107XG4gIHZhciB0cHJlZHNfbHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5zdGFnZXM7ICsraSkge1xuICAgIC8vIHJlYWQgdGhlIHRyZWVzIGZvciB0aGlzIHN0YWdlXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudHJlZXNwZXJzdGFnZTsgKytqKSB7XG4gICAgICAvLyBiaW5hcnkgdGVzdHMgKHdlIGNhbiByZWFkIGFsbCBvZiB0aGVtIGF0IG9uY2UpXG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0Y29kZXNfbHMsIGJ5dGVzLnNsaWNlKHAsIHAgKyA0ICogTWF0aC5wb3coMiwgdGRlcHRoKSAtIDQpKTtcbiAgICAgIHAgPSBwICsgNCAqIE1hdGgucG93KDIsIHRkZXB0aCkgLSA0OyAvLyByZWFkIHRoZSBwcmVkaWN0aW9uIGluIHRoZSBsZWFmIG5vZGVzIG9mIHRoZSB0cmVlXG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgTWF0aC5wb3coMiwgdGRlcHRoKTsgKytrKSB7XG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgMjsgKytsKSB7XG4gICAgICAgICAgZHZpZXcuc2V0VWludDgoMCwgYnl0ZXNbcCArIDBdKSwgZHZpZXcuc2V0VWludDgoMSwgYnl0ZXNbcCArIDFdKSwgZHZpZXcuc2V0VWludDgoMiwgYnl0ZXNbcCArIDJdKSwgZHZpZXcuc2V0VWludDgoMywgYnl0ZXNbcCArIDNdKTtcbiAgICAgICAgICB0cHJlZHNfbHMucHVzaChkdmlldy5nZXRGbG9hdDMyKDAsIHRydWUpKTtcbiAgICAgICAgICBwID0gcCArIDQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdGNvZGVzID0gbmV3IEludDhBcnJheSh0Y29kZXNfbHMpO1xuICB2YXIgdHByZWRzID0gbmV3IEZsb2F0MzJBcnJheSh0cHJlZHNfbHMpO1xuICAvKlxuICBjb25zdHJ1Y3QgdGhlIGxvY2F0aW9uIGVzdGltYXRvbiBmdW5jdGlvblxuICAqL1xuXG4gIGZ1bmN0aW9uIGxvY19mdW4ociwgYywgcywgcGl4ZWxzLCBucm93cywgbmNvbHMsIGxkaW0pIHtcbiAgICB2YXIgcm9vdCA9IDA7XG4gICAgdmFyIHBvdzJ0ZGVwdGggPSBNYXRoLnBvdygyLCB0ZGVwdGgpID4+IDA7IC8vICc+PjAnIHRyYW5zZm9ybXMgdGhpcyBudW1iZXIgdG8gaW50XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbnN0YWdlczsgKytfaSkge1xuICAgICAgdmFyIGRyID0gMC4wLFxuICAgICAgICAgIGRjID0gMC4wO1xuXG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbnRyZWVzcGVyc3RhZ2U7ICsrX2opIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IHRkZXB0aDsgKytfaykge1xuICAgICAgICAgIHZhciByMSA9IE1hdGgubWluKG5yb3dzIC0gMSwgTWF0aC5tYXgoMCwgMjU2ICogciArIHRjb2Rlc1tyb290ICsgNCAqIGlkeCArIDBdICogcyA+PiA4KSk7XG4gICAgICAgICAgdmFyIGMxID0gTWF0aC5taW4obmNvbHMgLSAxLCBNYXRoLm1heCgwLCAyNTYgKiBjICsgdGNvZGVzW3Jvb3QgKyA0ICogaWR4ICsgMV0gKiBzID4+IDgpKTtcbiAgICAgICAgICB2YXIgcjIgPSBNYXRoLm1pbihucm93cyAtIDEsIE1hdGgubWF4KDAsIDI1NiAqIHIgKyB0Y29kZXNbcm9vdCArIDQgKiBpZHggKyAyXSAqIHMgPj4gOCkpO1xuICAgICAgICAgIHZhciBjMiA9IE1hdGgubWluKG5jb2xzIC0gMSwgTWF0aC5tYXgoMCwgMjU2ICogYyArIHRjb2Rlc1tyb290ICsgNCAqIGlkeCArIDNdICogcyA+PiA4KSk7XG4gICAgICAgICAgaWR4ID0gMiAqIGlkeCArIDEgKyAocGl4ZWxzW3IxICogbGRpbSArIGMxXSA+IHBpeGVsc1tyMiAqIGxkaW0gKyBjMl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGx1dGlkeCA9IDIgKiAobnRyZWVzcGVyc3RhZ2UgKiBwb3cydGRlcHRoICogX2kgKyBwb3cydGRlcHRoICogX2ogKyBpZHggLSAocG93MnRkZXB0aCAtIDEpKTtcbiAgICAgICAgZHIgKz0gdHByZWRzW2x1dGlkeCArIDBdO1xuICAgICAgICBkYyArPSB0cHJlZHNbbHV0aWR4ICsgMV07XG4gICAgICAgIHJvb3QgKz0gNCAqIHBvdzJ0ZGVwdGggLSA0O1xuICAgICAgfVxuXG4gICAgICByID0gciArIGRyICogcztcbiAgICAgIGMgPSBjICsgZGMgKiBzO1xuICAgICAgcyA9IHMgKiBzY2FsZW11bDtcbiAgICB9XG5cbiAgICByZXR1cm4gW3IsIGNdO1xuICB9XG4gIC8qXG4gIHRoaXMgZnVuY3Rpb24gYXBwbGllcyByYW5kb20gcGVydHVyYmF0aW9ucyB0byB0aGUgZGVmYXVsdCByZWN0YW5nbGUgKHIsIGMsIHMpXG4gICovXG5cblxuICBmdW5jdGlvbiBsb2NfZnVuX3dpdGhfcGVydHVyYnMociwgYywgcywgbnBlcnR1cmJzLCBpbWFnZSkge1xuICAgIHZhciByb3dzID0gW10sXG4gICAgICAgIGNvbHMgPSBbXTtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5wZXJ0dXJiczsgKytfaTIpIHtcbiAgICAgIHZhciBfcyA9IHMgKiAoMC45MjUgKyAwLjE1ICogTWF0aC5yYW5kb20oKSk7XG5cbiAgICAgIHZhciBfciA9IHIgKyBzICogMC4xNSAqICgwLjUgLSBNYXRoLnJhbmRvbSgpKTtcblxuICAgICAgdmFyIF9jID0gYyArIHMgKiAwLjE1ICogKDAuNSAtIE1hdGgucmFuZG9tKCkpO1xuXG4gICAgICB2YXIgX2xvY19mdW4gPSBsb2NfZnVuKF9yLCBfYywgX3MsIGltYWdlLnBpeGVscywgaW1hZ2UubnJvd3MsIGltYWdlLm5jb2xzLCBpbWFnZS5sZGltKTtcblxuICAgICAgdmFyIF9sb2NfZnVuMiA9IF9zbGljZWRUb0FycmF5KF9sb2NfZnVuLCAyKTtcblxuICAgICAgX3IgPSBfbG9jX2Z1bjJbMF07XG4gICAgICBfYyA9IF9sb2NfZnVuMlsxXTtcbiAgICAgIHJvd3MucHVzaChfcik7XG4gICAgICBjb2xzLnB1c2goX2MpO1xuICAgIH0gLy8gcmV0dXJuIHRoZSBtZWRpYW4gYWxvbmcgZWFjaCBheGlzXG5cblxuICAgIHJvd3Muc29ydCgpO1xuICAgIGNvbHMuc29ydCgpO1xuICAgIHJldHVybiBbcm93c1tNYXRoLnJvdW5kKG5wZXJ0dXJicyAvIDIpXSwgY29sc1tNYXRoLnJvdW5kKG5wZXJ0dXJicyAvIDIpXV07XG4gIH1cbiAgLypcbiAgd2UncmUgZG9uZVxuICAqL1xuXG5cbiAgcmV0dXJuIGxvY19mdW5fd2l0aF9wZXJ0dXJicztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGxwbG9jOyIsImV4cG9ydCBmdW5jdGlvbiByZ2JhX3RvX2dyYXlzY2FsZShyZ2JhLCBucm93cywgbmNvbHMpIHtcbiAgdmFyIGdyYXkgPSBuZXcgVWludDhBcnJheShucm93cyAqIG5jb2xzKTtcblxuICBmb3IgKHZhciByID0gMDsgciA8IG5yb3dzOyArK3IpIHtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IG5jb2xzOyArK2MpIHtcbiAgICAgIC8vIGdyYXkgPSAwLjIqcmVkICsgMC43KmdyZWVuICsgMC4xKmJsdWVcbiAgICAgIGdyYXlbciAqIG5jb2xzICsgY10gPSAoMiAqIHJnYmFbciAqIDQgKiBuY29scyArIDQgKiBjICsgMF0gKyA3ICogcmdiYVtyICogNCAqIG5jb2xzICsgNCAqIGMgKyAxXSArIDEgKiByZ2JhW3IgKiA0ICogbmNvbHMgKyA0ICogYyArIDJdKSAvIDEwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBncmF5O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNhbnZhc190b19pbWFnZShjYW52YXMpIHtcbiAgdmFyIGltZyA9IGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgcmV0dXJuIGltZztcbn0iLCJpbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheVwiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgcGljbyBmcm9tIFwiLi4vLi4vLi4vY29tcG9uZW50cy9waWNvL3BpY28uanNcIjtcbmltcG9ydCBscGxvYyBmcm9tIFwiLi4vLi4vLi4vY29tcG9uZW50cy9waWNvL2xwbG9jLmpzXCI7XG5pbXBvcnQgeyByZ2JhX3RvX2dyYXlzY2FsZSB9IGZyb20gXCIuLi8uLi8uLi9jb21wb25lbnRzL3BpY28vdXRpbGl0eS9pbmRleC5qc1wiO1xuXG5mdW5jdGlvbiBQaWNvKHByb3BzKSB7XG4gIHZhciB2aWRlbyA9IHByb3BzLnZpZGVvLFxuICAgICAgX3Byb3BzJHNjb3JlID0gcHJvcHMuc2NvcmUsXG4gICAgICBzY29yZSA9IF9wcm9wcyRzY29yZSA9PT0gdm9pZCAwID8gMTAwIDogX3Byb3BzJHNjb3JlO1xuICB2YXIgY3R4X3JlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHNjb3JlX3JlZiA9IHVzZVJlZihzY29yZSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgc2NvcmVfcmVmLmN1cnJlbnQgPSBzY29yZTtcbiAgfSwgW3Njb3JlXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHZpZGVvKSB7XG4gICAgICB2YXIgY2FuY2VsID0gZmFsc2U7XG4gICAgICB2YXIgY3R4ID0gY3R4X3JlZi5jdXJyZW50LmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIHZhciB1cGRhdGVfbWVtb3J5ID0gcGljby5pbnN0YW50aWF0ZV9kZXRlY3Rpb25fbWVtb3J5KDUpO1xuICAgICAgdmFyIGZldGNoX3B1cGxvYyA9IGZldGNoKFwiLi9kYXRhL3B1cGxvYy5iaW5cIikudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGxwbG9jLnVucGFja19sb2NhbGl6ZXIobmV3IEludDhBcnJheShidWZmZXIpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGZldGNoX2ZhY2UgPSBmZXRjaChcIi4vZGF0YS9mYWNlZmluZGVyXCIpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBwaWNvLnVucGFja19jYXNjYWRlKG5ldyBJbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgIHNoaWZ0ZmFjdG9yOiAwLjEsXG4gICAgICAgIC8vIG1vdmUgdGhlIGRldGVjdGlvbiB3aW5kb3cgYnkgMTAlIG9mIGl0cyBzaXplXG4gICAgICAgIG1pbnNpemU6IDEwMCxcbiAgICAgICAgLy8gbWluaW11bSBzaXplIG9mIGEgZmFjZVxuICAgICAgICBtYXhzaXplOiAxMDAwLFxuICAgICAgICAvLyBtYXhpbXVtIHNpemUgb2YgYSBmYWNlXG4gICAgICAgIHNjYWxlZmFjdG9yOiAxLjEgLy8gZm9yIG11bHRpc2NhbGUgcHJvY2Vzc2luZzogcmVzaXplIHRoZSBkZXRlY3Rpb24gd2luZG93IGJ5IDEwJSB3aGVuIG1vdmluZyB0byB0aGUgaGlnaGVyIHNjYWxlXG5cbiAgICAgIH07XG4gICAgICBQcm9taXNlLmFsbChbZmV0Y2hfZmFjZSwgZmV0Y2hfcHVwbG9jXSkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgIGZhY2VmaW5kZXJfY2xhc3NpZnlfcmVnaW9uID0gX3JlZjJbMF0sXG4gICAgICAgICAgICBkb19wdXBsb2MgPSBfcmVmMlsxXTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRWaWRlb0ZyYW1lKCkge1xuICAgICAgICAgIGlmIChjYW5jZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHguZHJhd0ltYWdlKHZpZGVvLCAwLCAwKTtcbiAgICAgICAgICB2YXIgcmdiYSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgNjQwLCA0ODApLmRhdGE7XG4gICAgICAgICAgdmFyIGltYWdlID0ge1xuICAgICAgICAgICAgcGl4ZWxzOiByZ2JhX3RvX2dyYXlzY2FsZShyZ2JhLCA0ODAsIDY0MCksXG4gICAgICAgICAgICBucm93czogNDgwLFxuICAgICAgICAgICAgbmNvbHM6IDY0MCxcbiAgICAgICAgICAgIGxkaW06IDY0MFxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGRldHMgPSBwaWNvLnJ1bl9jYXNjYWRlKGltYWdlLCBmYWNlZmluZGVyX2NsYXNzaWZ5X3JlZ2lvbiwgcGFyYW1zKTtcbiAgICAgICAgICBkZXRzID0gdXBkYXRlX21lbW9yeShkZXRzKTtcbiAgICAgICAgICBkZXRzID0gcGljby5jbHVzdGVyX2RldGVjdGlvbnMoZGV0cywgMC4yKTsgLy8gc2V0IElvVSB0aHJlc2hvbGQgdG8gMC4yXG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChkZXRzW2ldWzNdID4gc2NvcmVfcmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICBjdHguYXJjKGRldHNbaV1bMV0sIGRldHNbaV1bMF0sIGRldHNbaV1bMl0gLyAyLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMztcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZWRcIjtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICB2YXIgciA9IGRldHNbaV1bMF0gLSAwLjA3NSAqIGRldHNbaV1bMl07XG4gICAgICAgICAgICAgIHZhciBjID0gZGV0c1tpXVsxXSAtIDAuMTc1ICogZGV0c1tpXVsyXTtcbiAgICAgICAgICAgICAgdmFyIHMgPSAwLjM1ICogZGV0c1tpXVsyXTtcblxuICAgICAgICAgICAgICB2YXIgX2RvX3B1cGxvYyA9IGRvX3B1cGxvYyhyLCBjLCBzLCA2MywgaW1hZ2UpO1xuXG4gICAgICAgICAgICAgIHZhciBfZG9fcHVwbG9jMiA9IF9zbGljZWRUb0FycmF5KF9kb19wdXBsb2MsIDIpO1xuXG4gICAgICAgICAgICAgIHIgPSBfZG9fcHVwbG9jMlswXTtcbiAgICAgICAgICAgICAgYyA9IF9kb19wdXBsb2MyWzFdO1xuXG4gICAgICAgICAgICAgIGlmIChyID49IDAgJiYgYyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoYywgciwgMSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMztcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHIgPSBkZXRzW2ldWzBdIC0gMC4wNzUgKiBkZXRzW2ldWzJdO1xuICAgICAgICAgICAgICBjID0gZGV0c1tpXVsxXSArIDAuMTc1ICogZGV0c1tpXVsyXTtcbiAgICAgICAgICAgICAgcyA9IDAuMzUgKiBkZXRzW2ldWzJdO1xuXG4gICAgICAgICAgICAgIHZhciBfZG9fcHVwbG9jMyA9IGRvX3B1cGxvYyhyLCBjLCBzLCA2MywgaW1hZ2UpO1xuXG4gICAgICAgICAgICAgIHZhciBfZG9fcHVwbG9jNCA9IF9zbGljZWRUb0FycmF5KF9kb19wdXBsb2MzLCAyKTtcblxuICAgICAgICAgICAgICByID0gX2RvX3B1cGxvYzRbMF07XG4gICAgICAgICAgICAgIGMgPSBfZG9fcHVwbG9jNFsxXTtcblxuICAgICAgICAgICAgICBpZiAociA+PSAwICYmIGMgPj0gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKGMsIHIsIDEsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZWRcIjtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFZpZGVvRnJhbWUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFZpZGVvRnJhbWUoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbdmlkZW9dKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwge1xuICAgIHdpZHRoOiA2NDAsXG4gICAgaGVpZ2h0OiA0ODAsXG4gICAgcmVmOiBjdHhfcmVmXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKFBpY28pOyIsImltcG9ydCBfQmFja1RvcCBmcm9tIFwiYW50ZC9saWIvYmFjay10b3BcIjtcbmltcG9ydCBfQ2FyZCBmcm9tIFwiYW50ZC9saWIvY2FyZFwiO1xuaW1wb3J0IF9TbGlkZXIgZnJvbSBcImFudGQvbGliL3NsaWRlclwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBXZWJSVEMgZnJvbSBcIi4vd2ViLXJ0Yy5qc1wiO1xuaW1wb3J0IFBpY29EZXRlY3QgZnJvbSBcIi4vcGljby1kZXRlY3QuanNcIjtcblxuZnVuY3Rpb24gRmFjZURldGVjdCgpIHtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKDEwMCksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIHNjb3JlID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldFNjb3JlID0gX3VzZVN0YXRlMlsxXTtcblxuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKCksXG4gICAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMiksXG4gICAgICB2aWRlbyA9IF91c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRWaWRlbyA9IF91c2VTdGF0ZTRbMV07XG5cbiAgdmFyIG9uQWZ0ZXJDaGFuZ2UgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsKSB7XG4gICAgc2V0SW1nKFtdKTtcbiAgICBzZXRTY29yZSh2YWwpO1xuICB9LCBbXSk7XG4gIHZhciBvbmNhbnBsYXkgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmlkZW8pIHtcbiAgICBzZXRWaWRlbyh2aWRlbyk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX0NhcmQsIHtcbiAgICBzdHlsZToge1xuICAgICAgbWFyZ2luQm90dG9tOiAyNFxuICAgIH1cbiAgfSwgXCJBY2N1cmFjeTpcIiwgUmVhY3QuY3JlYXRlRWxlbWVudChfU2xpZGVyLCB7XG4gICAgZGVmYXVsdFZhbHVlOiBzY29yZSxcbiAgICBtYXg6IDUwMCxcbiAgICBtaW46IDUwLFxuICAgIG1hcmtzOiB7XG4gICAgICA1MDA6IFwiNTAwXCIsXG4gICAgICA1MDogXCI1MFwiXG4gICAgfSxcbiAgICBvbkFmdGVyQ2hhbmdlOiBvbkFmdGVyQ2hhbmdlLFxuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogMjAwXG4gICAgfVxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIG1hcmdpblRvcDogNDBcbiAgICB9XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoV2ViUlRDLCB7XG4gICAgb25jYW5wbGF5OiBvbmNhbnBsYXlcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGljb0RldGVjdCwge1xuICAgIHZpZGVvOiB2aWRlbyxcbiAgICBzY29yZTogc2NvcmVcbiAgfSkpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChfQmFja1RvcCwgbnVsbCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKEZhY2VEZXRlY3QpOyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///640\n')}}]);