(this.webpackJsonp=this.webpackJsonp||[]).push([[8],{618:function(module,exports,__webpack_require__){eval("var api = __webpack_require__(78);\n            var content = __webpack_require__(619);\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\nvar exported = content.locals ? content.locals : {};\n\n\n\nmodule.exports = exported;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3d3dy9jb21wb25lbnQvc25hcHNob3Qvd2ViLXJ0Yy5jc3NtP2YwZGIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LTEhLi93ZWItcnRjLmNzc21cIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cbnZhciBleHBvcnRlZCA9IGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB7fTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZWQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///618\n")},619:function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(79);\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, ".web-rtc__video___1_1no {\\r\\n  display: none;\\r\\n}\\r\\n", ""]);\n// Exports\nexports.locals = {\n\t"video": "web-rtc__video___1_1no"\n};\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3d3dy9jb21wb25lbnQvc25hcHNob3Qvd2ViLXJ0Yy5jc3NtPzNmMmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi53ZWItcnRjX192aWRlb19fXzFfMW5vIHtcXHJcXG4gIGRpc3BsYXk6IG5vbmU7XFxyXFxufVxcclxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJ2aWRlb1wiOiBcIndlYi1ydGNfX3ZpZGVvX19fMV8xbm9cIlxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///619\n')},634:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/antd/lib/back-top/index.js\nvar back_top = __webpack_require__(434);\nvar back_top_default = /*#__PURE__*/__webpack_require__.n(back_top);\n\n// EXTERNAL MODULE: ./node_modules/antd/lib/card/index.js\nvar card = __webpack_require__(421);\nvar card_default = /*#__PURE__*/__webpack_require__.n(card);\n\n// EXTERNAL MODULE: ./node_modules/antd/lib/slider/index.js\nvar slider = __webpack_require__(620);\nvar slider_default = /*#__PURE__*/__webpack_require__.n(slider);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js\nvar slicedToArray = __webpack_require__(110);\nvar slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);\n\n// EXTERNAL MODULE: external "React"\nvar external_React_ = __webpack_require__(0);\nvar external_React_default = /*#__PURE__*/__webpack_require__.n(external_React_);\n\n// EXTERNAL MODULE: ./node_modules/react-hooks/useMediaDevices.js\nvar useMediaDevices = __webpack_require__(617);\n\n// EXTERNAL MODULE: ./src/www/component/snapshot/web-rtc.cssm\nvar web_rtc = __webpack_require__(618);\nvar web_rtc_default = /*#__PURE__*/__webpack_require__.n(web_rtc);\n\n// CONCATENATED MODULE: ./src/www/component/snapshot/web-rtc.js\n\n\n\n\nfunction WebRTC(props, ref) {\n  var video_ref = Object(external_React_["useRef"])();\n  var video_ready = Object(useMediaDevices["a" /* default */])(video_ref);\n  Object(external_React_["useEffect"])(function () {\n    if (video_ready) {\n      var video = video_ref.current;\n      props.oncanplay(video);\n    }\n  }, [video_ready]);\n  return /*#__PURE__*/external_React_default.a.createElement("video", {\n    autoPlay: true,\n    muted: true,\n    ref: video_ref,\n    className: web_rtc_default.a.video\n  });\n}\n\n/* harmony default export */ var snapshot_web_rtc = (external_React_default.a.memo(external_React_default.a.forwardRef(WebRTC)));\n// CONCATENATED MODULE: ./src/components/pico/pico.js\n/* This library is released under the MIT license, see https://github.com/tehnokv/picojs */\nvar pico = {};\n\npico.unpack_cascade = function (bytes) {\n  //\n  var dview = new DataView(new ArrayBuffer(4));\n  /*\r\n  we skip the first 8 bytes of the cascade file\r\n  (cascade version number and some data used during the learning process)\r\n  */\n\n  var p = 8;\n  /*\r\n  read the depth (size) of each tree first: a 32-bit signed integer\r\n  */\n\n  dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n  var tdepth = dview.getInt32(0, true);\n  p = p + 4;\n  /*\r\n  next, read the number of trees in the cascade: another 32-bit signed integer\r\n  */\n\n  dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n  var ntrees = dview.getInt32(0, true);\n  p = p + 4;\n  /*\r\n  read the actual trees and cascade thresholds\r\n  */\n\n  var tcodes_ls = [];\n  var tpreds_ls = [];\n  var thresh_ls = [];\n\n  for (var t = 0; t < ntrees; ++t) {\n    // read the binary tests placed in internal tree nodes\n    Array.prototype.push.apply(tcodes_ls, [0, 0, 0, 0]);\n    Array.prototype.push.apply(tcodes_ls, bytes.slice(p, p + 4 * Math.pow(2, tdepth) - 4));\n    p = p + 4 * Math.pow(2, tdepth) - 4; // read the prediction in the leaf nodes of the tree\n\n    for (var i = 0; i < Math.pow(2, tdepth); ++i) {\n      dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n      tpreds_ls.push(dview.getFloat32(0, true));\n      p = p + 4;\n    } // read the threshold\n\n\n    dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n    thresh_ls.push(dview.getFloat32(0, true));\n    p = p + 4;\n  }\n\n  var tcodes = new Int8Array(tcodes_ls);\n  var tpreds = new Float32Array(tpreds_ls);\n  var thresh = new Float32Array(thresh_ls);\n  /*\r\n  construct the classification function from the read data\r\n  */\n\n  function classify_region(r, c, s, pixels, ldim) {\n    r = 256 * r;\n    c = 256 * c;\n    var root = 0;\n    var o = 0.0;\n    var pow2tdepth = Math.pow(2, tdepth) >> 0; // \'>>0\' transforms this number to int\n\n    for (var _i = 0; _i < ntrees; ++_i) {\n      var idx = 1;\n\n      for (var j = 0; j < tdepth; ++j) {\n        // we use \'>> 8\' here to perform an integer division: this seems important for performance\n        idx = 2 * idx + (pixels[(r + tcodes[root + 4 * idx + 0] * s >> 8) * ldim + (c + tcodes[root + 4 * idx + 1] * s >> 8)] <= pixels[(r + tcodes[root + 4 * idx + 2] * s >> 8) * ldim + (c + tcodes[root + 4 * idx + 3] * s >> 8)]);\n      }\n\n      o = o + tpreds[pow2tdepth * _i + idx - pow2tdepth];\n      if (o <= thresh[_i]) return -1;\n      root += 4 * pow2tdepth;\n    }\n\n    return o - thresh[ntrees - 1];\n  }\n  /*\r\n  we\'re done\r\n  */\n\n\n  return classify_region;\n};\n\npico.run_cascade = function (image, classify_region, params) {\n  var pixels = image.pixels;\n  var nrows = image.nrows;\n  var ncols = image.ncols;\n  var ldim = image.ldim;\n  var shiftfactor = params.shiftfactor;\n  var minsize = params.minsize;\n  var maxsize = params.maxsize;\n  var scalefactor = params.scalefactor;\n  var scale = minsize;\n  var detections = [];\n\n  while (scale <= maxsize) {\n    var step = Math.max(shiftfactor * scale, 1) >> 0; // \'>>0\' transforms this number to int\n\n    var offset = scale / 2 + 1 >> 0;\n\n    for (var r = offset; r <= nrows - offset; r += step) {\n      for (var c = offset; c <= ncols - offset; c += step) {\n        var q = classify_region(r, c, scale, pixels, ldim);\n        if (q > 0.0) detections.push([r, c, scale, q]);\n      }\n    }\n\n    scale = scale * scalefactor;\n  }\n\n  return detections;\n};\n\npico.cluster_detections = function (dets, iouthreshold) {\n  /*\r\n  sort detections by their score\r\n  */\n  dets = dets.sort(function (a, b) {\n    return b[3] - a[3];\n  });\n  /*\r\n  this helper function calculates the intersection over union for two detections\r\n  */\n\n  function calculate_iou(det1, det2) {\n    // unpack the position and size of each detection\n    var r1 = det1[0],\n        c1 = det1[1],\n        s1 = det1[2];\n    var r2 = det2[0],\n        c2 = det2[1],\n        s2 = det2[2]; // calculate detection overlap in each dimension\n\n    var overr = Math.max(0, Math.min(r1 + s1 / 2, r2 + s2 / 2) - Math.max(r1 - s1 / 2, r2 - s2 / 2));\n    var overc = Math.max(0, Math.min(c1 + s1 / 2, c2 + s2 / 2) - Math.max(c1 - s1 / 2, c2 - s2 / 2)); // calculate and return IoU\n\n    return overr * overc / (s1 * s1 + s2 * s2 - overr * overc);\n  }\n  /*\r\n  do clustering through non-maximum suppression\r\n  */\n\n\n  var assignments = new Array(dets.length).fill(0);\n  var clusters = [];\n\n  for (var i = 0; i < dets.length; ++i) {\n    // is this detection assigned to a cluster?\n    if (assignments[i] == 0) {\n      // it is not:\n      // now we make a cluster out of it and see whether some other detections belong to it\n      var r = 0.0,\n          c = 0.0,\n          s = 0.0,\n          q = 0.0,\n          n = 0;\n\n      for (var j = i; j < dets.length; ++j) {\n        if (calculate_iou(dets[i], dets[j]) > iouthreshold) {\n          assignments[j] = 1;\n          r = r + dets[j][0];\n          c = c + dets[j][1];\n          s = s + dets[j][2];\n          q = q + dets[j][3];\n          n = n + 1;\n        }\n      } // make a cluster representative\n\n\n      clusters.push([r / n, c / n, s / n, q]);\n    }\n  }\n\n  return clusters;\n};\n\npico.instantiate_detection_memory = function (size) {\n  /*\r\n  initialize a circular buffer of `size` elements\r\n  */\n  var n = 0;\n  var memory = [];\n\n  for (var i = 0; i < size; ++i) {\n    memory.push([]);\n  }\n  /*\r\n  build a function that:\r\n  (1) inserts the current frame\'s detections into the buffer;\r\n  (2) merges all detections from the last `size` frames and returns them\r\n  */\n\n\n  function update_memory(dets) {\n    memory[n] = dets;\n    n = (n + 1) % memory.length;\n    dets = [];\n\n    for (var _i2 = 0; _i2 < memory.length; ++_i2) {\n      dets = dets.concat(memory[_i2]);\n    } //\n\n\n    return dets;\n  }\n  /*\r\n  we\'re done\r\n  */\n\n\n  return update_memory;\n};\n\n/* harmony default export */ var pico_pico = (pico);\n// CONCATENATED MODULE: ./src/components/pico/lploc.js\n\n\n/* This library is released under the MIT license, contact @tehnokv for more details */\nvar lploc = {};\n\nlploc.unpack_localizer = function (bytes) {\n  //\n  var dview = new DataView(new ArrayBuffer(4));\n  var p = 0;\n  /*\r\n  read the number of stages, scale multiplier (applied after each stage),\r\n  number of trees per stage and depth of each tree\r\n  */\n\n  dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n  var nstages = dview.getInt32(0, true);\n  p = p + 4;\n  dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n  var scalemul = dview.getFloat32(0, true);\n  p = p + 4;\n  dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n  var ntreesperstage = dview.getInt32(0, true);\n  p = p + 4;\n  dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n  var tdepth = dview.getInt32(0, true);\n  p = p + 4;\n  /*\r\n  unpack the trees\r\n  */\n\n  var tcodes_ls = [];\n  var tpreds_ls = [];\n\n  for (var i = 0; i < nstages; ++i) {\n    // read the trees for this stage\n    for (var j = 0; j < ntreesperstage; ++j) {\n      // binary tests (we can read all of them at once)\n      Array.prototype.push.apply(tcodes_ls, bytes.slice(p, p + 4 * Math.pow(2, tdepth) - 4));\n      p = p + 4 * Math.pow(2, tdepth) - 4; // read the prediction in the leaf nodes of the tree\n\n      for (var k = 0; k < Math.pow(2, tdepth); ++k) {\n        for (var l = 0; l < 2; ++l) {\n          dview.setUint8(0, bytes[p + 0]), dview.setUint8(1, bytes[p + 1]), dview.setUint8(2, bytes[p + 2]), dview.setUint8(3, bytes[p + 3]);\n          tpreds_ls.push(dview.getFloat32(0, true));\n          p = p + 4;\n        }\n      }\n    }\n  }\n\n  var tcodes = new Int8Array(tcodes_ls);\n  var tpreds = new Float32Array(tpreds_ls);\n  /*\r\n  construct the location estimaton function\r\n  */\n\n  function loc_fun(r, c, s, pixels, nrows, ncols, ldim) {\n    var root = 0;\n    var pow2tdepth = Math.pow(2, tdepth) >> 0; // \'>>0\' transforms this number to int\n\n    for (var _i = 0; _i < nstages; ++_i) {\n      var dr = 0.0,\n          dc = 0.0;\n\n      for (var _j = 0; _j < ntreesperstage; ++_j) {\n        var idx = 0;\n\n        for (var _k = 0; _k < tdepth; ++_k) {\n          var r1 = Math.min(nrows - 1, Math.max(0, 256 * r + tcodes[root + 4 * idx + 0] * s >> 8));\n          var c1 = Math.min(ncols - 1, Math.max(0, 256 * c + tcodes[root + 4 * idx + 1] * s >> 8));\n          var r2 = Math.min(nrows - 1, Math.max(0, 256 * r + tcodes[root + 4 * idx + 2] * s >> 8));\n          var c2 = Math.min(ncols - 1, Math.max(0, 256 * c + tcodes[root + 4 * idx + 3] * s >> 8));\n          idx = 2 * idx + 1 + (pixels[r1 * ldim + c1] > pixels[r2 * ldim + c2]);\n        }\n\n        var lutidx = 2 * (ntreesperstage * pow2tdepth * _i + pow2tdepth * _j + idx - (pow2tdepth - 1));\n        dr += tpreds[lutidx + 0];\n        dc += tpreds[lutidx + 1];\n        root += 4 * pow2tdepth - 4;\n      }\n\n      r = r + dr * s;\n      c = c + dc * s;\n      s = s * scalemul;\n    }\n\n    return [r, c];\n  }\n  /*\r\n  this function applies random perturbations to the default rectangle (r, c, s)\r\n  */\n\n\n  function loc_fun_with_perturbs(r, c, s, nperturbs, image) {\n    var rows = [],\n        cols = [];\n\n    for (var _i2 = 0; _i2 < nperturbs; ++_i2) {\n      var _s = s * (0.925 + 0.15 * Math.random());\n\n      var _r = r + s * 0.15 * (0.5 - Math.random());\n\n      var _c = c + s * 0.15 * (0.5 - Math.random());\n\n      var _loc_fun = loc_fun(_r, _c, _s, image.pixels, image.nrows, image.ncols, image.ldim);\n\n      var _loc_fun2 = slicedToArray_default()(_loc_fun, 2);\n\n      _r = _loc_fun2[0];\n      _c = _loc_fun2[1];\n      rows.push(_r);\n      cols.push(_c);\n    } // return the median along each axis\n\n\n    rows.sort();\n    cols.sort();\n    return [rows[Math.round(nperturbs / 2)], cols[Math.round(nperturbs / 2)]];\n  }\n  /*\r\n  we\'re done\r\n  */\n\n\n  return loc_fun_with_perturbs;\n};\n\n/* harmony default export */ var pico_lploc = (lploc);\n// CONCATENATED MODULE: ./src/components/pico/utility/index.js\nfunction rgba_to_grayscale(rgba, nrows, ncols) {\n  var gray = new Uint8Array(nrows * ncols);\n\n  for (var r = 0; r < nrows; ++r) {\n    for (var c = 0; c < ncols; ++c) {\n      // gray = 0.2*red + 0.7*green + 0.1*blue\n      gray[r * ncols + c] = (2 * rgba[r * 4 * ncols + 4 * c + 0] + 7 * rgba[r * 4 * ncols + 4 * c + 1] + 1 * rgba[r * 4 * ncols + 4 * c + 2]) / 10;\n    }\n  }\n\n  return gray;\n}\nfunction canvas_to_image(canvas) {\n  var img = canvas.toDataURL();\n  return img;\n}\n// CONCATENATED MODULE: ./src/www/component/snapshot/pico-detect.js\n\n\n\n\n\n\nfunction Pico(props) {\n  var video = props.video,\n      _props$score = props.score,\n      score = _props$score === void 0 ? 100 : _props$score;\n  var ctx_ref = Object(external_React_["useRef"])(null);\n  var score_ref = Object(external_React_["useRef"])(score);\n  Object(external_React_["useEffect"])(function () {\n    score_ref.current = score;\n  }, [score]);\n  Object(external_React_["useEffect"])(function () {\n    if (video) {\n      var cancel = false;\n      var ctx = ctx_ref.current.getContext("2d");\n      var update_memory = pico_pico.instantiate_detection_memory(5);\n      var fetch_puploc = fetch("./data/puploc.bin").then(function (response) {\n        return response.arrayBuffer();\n      }).then(function (buffer) {\n        return pico_lploc.unpack_localizer(new Int8Array(buffer));\n      });\n      var fetch_face = fetch("./data/facefinder").then(function (response) {\n        return response.arrayBuffer();\n      }).then(function (buffer) {\n        return pico_pico.unpack_cascade(new Int8Array(buffer));\n      });\n      var params = {\n        shiftfactor: 0.1,\n        // move the detection window by 10% of its size\n        minsize: 100,\n        // minimum size of a face\n        maxsize: 1000,\n        // maximum size of a face\n        scalefactor: 1.1 // for multiscale processing: resize the detection window by 10% when moving to the higher scale\n\n      };\n      Promise.all([fetch_face, fetch_puploc]).then(function (_ref) {\n        var _ref2 = slicedToArray_default()(_ref, 2),\n            facefinder_classify_region = _ref2[0],\n            do_puploc = _ref2[1];\n\n        function getVideoFrame() {\n          if (cancel) {\n            return;\n          }\n\n          ctx.drawImage(video, 0, 0);\n          var rgba = ctx.getImageData(0, 0, 640, 480).data;\n          var image = {\n            pixels: rgba_to_grayscale(rgba, 480, 640),\n            nrows: 480,\n            ncols: 640,\n            ldim: 640\n          };\n          var dets = pico_pico.run_cascade(image, facefinder_classify_region, params);\n          dets = update_memory(dets);\n          dets = pico_pico.cluster_detections(dets, 0.2); // set IoU threshold to 0.2\n\n          for (var i = 0; i < dets.length; ++i) {\n            if (dets[i][3] > score_ref.current) {\n              ctx.beginPath();\n              ctx.arc(dets[i][1], dets[i][0], dets[i][2] / 2, 0, 2 * Math.PI, false);\n              ctx.lineWidth = 3;\n              ctx.strokeStyle = "red";\n              ctx.stroke();\n              var r = dets[i][0] - 0.075 * dets[i][2];\n              var c = dets[i][1] - 0.175 * dets[i][2];\n              var s = 0.35 * dets[i][2];\n\n              var _do_puploc = do_puploc(r, c, s, 63, image);\n\n              var _do_puploc2 = slicedToArray_default()(_do_puploc, 2);\n\n              r = _do_puploc2[0];\n              c = _do_puploc2[1];\n\n              if (r >= 0 && c >= 0) {\n                ctx.beginPath();\n                ctx.arc(c, r, 1, 0, 2 * Math.PI, false);\n                ctx.lineWidth = 3;\n                ctx.strokeStyle = "red";\n                ctx.stroke();\n              }\n\n              r = dets[i][0] - 0.075 * dets[i][2];\n              c = dets[i][1] + 0.175 * dets[i][2];\n              s = 0.35 * dets[i][2];\n\n              var _do_puploc3 = do_puploc(r, c, s, 63, image);\n\n              var _do_puploc4 = slicedToArray_default()(_do_puploc3, 2);\n\n              r = _do_puploc4[0];\n              c = _do_puploc4[1];\n\n              if (r >= 0 && c >= 0) {\n                ctx.beginPath();\n                ctx.arc(c, r, 1, 0, 2 * Math.PI, false);\n                ctx.lineWidth = 3;\n                ctx.strokeStyle = "red";\n                ctx.stroke();\n              }\n            }\n          }\n\n          requestAnimationFrame(function () {\n            return getVideoFrame();\n          });\n        }\n\n        getVideoFrame();\n      });\n      return function () {\n        cancel = true;\n      };\n    }\n  }, [video]);\n  return /*#__PURE__*/external_React_default.a.createElement("canvas", {\n    width: 640,\n    height: 480,\n    ref: ctx_ref\n  });\n}\n\n/* harmony default export */ var pico_detect = (external_React_default.a.memo(Pico));\n// CONCATENATED MODULE: ./src/www/component/snapshot/index.js\n\n\n\n\n\n\n\n\nfunction FaceDetect() {\n  var _useState = Object(external_React_["useState"])(100),\n      _useState2 = slicedToArray_default()(_useState, 2),\n      score = _useState2[0],\n      setScore = _useState2[1];\n\n  var _useState3 = Object(external_React_["useState"])(),\n      _useState4 = slicedToArray_default()(_useState3, 2),\n      video = _useState4[0],\n      setVideo = _useState4[1];\n\n  var onAfterChange = Object(external_React_["useCallback"])(function (val) {\n    setImg([]);\n    setScore(val);\n  }, []);\n  var oncanplay = Object(external_React_["useCallback"])(function (video) {\n    setVideo(video);\n  }, []);\n  return /*#__PURE__*/external_React_default.a.createElement(external_React_default.a.Fragment, null, /*#__PURE__*/external_React_default.a.createElement(card_default.a, {\n    style: {\n      marginBottom: 24\n    }\n  }, "Accuracy:", /*#__PURE__*/external_React_default.a.createElement(slider_default.a, {\n    defaultValue: score,\n    max: 500,\n    min: 50,\n    marks: {\n      500: "500",\n      50: "50"\n    },\n    onAfterChange: onAfterChange,\n    style: {\n      width: 200\n    }\n  }), /*#__PURE__*/external_React_default.a.createElement("div", {\n    style: {\n      marginTop: 40\n    }\n  }, /*#__PURE__*/external_React_default.a.createElement(snapshot_web_rtc, {\n    oncanplay: oncanplay\n  }), /*#__PURE__*/external_React_default.a.createElement(pico_detect, {\n    video: video,\n    score: score\n  }))), /*#__PURE__*/external_React_default.a.createElement(back_top_default.a, null));\n}\n\n/* harmony default export */ var snapshot = __webpack_exports__["default"] = (external_React_default.a.memo(FaceDetect));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjM0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3d3dy9jb21wb25lbnQvc25hcHNob3Qvd2ViLXJ0Yy5qcz82NjNmIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3BpY28vcGljby5qcz9lZDNhIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3BpY28vbHBsb2MuanM/NGZlYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9waWNvL3V0aWxpdHkvaW5kZXguanM/MDJiYSIsIndlYnBhY2s6Ly8vLi9zcmMvd3d3L2NvbXBvbmVudC9zbmFwc2hvdC9waWNvLWRldGVjdC5qcz9lMmNiIiwid2VicGFjazovLy8uL3NyYy93d3cvY29tcG9uZW50L3NuYXBzaG90L2luZGV4LmpzPzZhMjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdXNlTWVkaWFEZXZpY2VzIGZyb20gXCJyZWFjdC1ob29rcy91c2VNZWRpYURldmljZXMuanNcIjtcbmltcG9ydCBzdHlsZXMgZnJvbSBcIi4vd2ViLXJ0Yy5jc3NtXCI7XG5cbmZ1bmN0aW9uIFdlYlJUQyhwcm9wcywgcmVmKSB7XG4gIHZhciB2aWRlb19yZWYgPSB1c2VSZWYoKTtcbiAgdmFyIHZpZGVvX3JlYWR5ID0gdXNlTWVkaWFEZXZpY2VzKHZpZGVvX3JlZik7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHZpZGVvX3JlYWR5KSB7XG4gICAgICB2YXIgdmlkZW8gPSB2aWRlb19yZWYuY3VycmVudDtcbiAgICAgIHByb3BzLm9uY2FucGxheSh2aWRlbyk7XG4gICAgfVxuICB9LCBbdmlkZW9fcmVhZHldKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIiwge1xuICAgIGF1dG9QbGF5OiB0cnVlLFxuICAgIG11dGVkOiB0cnVlLFxuICAgIHJlZjogdmlkZW9fcmVmLFxuICAgIGNsYXNzTmFtZTogc3R5bGVzLnZpZGVvXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKFJlYWN0LmZvcndhcmRSZWYoV2ViUlRDKSk7IiwiLyogVGhpcyBsaWJyYXJ5IGlzIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90ZWhub2t2L3BpY29qcyAqL1xudmFyIHBpY28gPSB7fTtcblxucGljby51bnBhY2tfY2FzY2FkZSA9IGZ1bmN0aW9uIChieXRlcykge1xuICAvL1xuICB2YXIgZHZpZXcgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDQpKTtcbiAgLypcclxuICB3ZSBza2lwIHRoZSBmaXJzdCA4IGJ5dGVzIG9mIHRoZSBjYXNjYWRlIGZpbGVcclxuICAoY2FzY2FkZSB2ZXJzaW9uIG51bWJlciBhbmQgc29tZSBkYXRhIHVzZWQgZHVyaW5nIHRoZSBsZWFybmluZyBwcm9jZXNzKVxyXG4gICovXG5cbiAgdmFyIHAgPSA4O1xuICAvKlxyXG4gIHJlYWQgdGhlIGRlcHRoIChzaXplKSBvZiBlYWNoIHRyZWUgZmlyc3Q6IGEgMzItYml0IHNpZ25lZCBpbnRlZ2VyXHJcbiAgKi9cblxuICBkdmlldy5zZXRVaW50OCgwLCBieXRlc1twICsgMF0pLCBkdmlldy5zZXRVaW50OCgxLCBieXRlc1twICsgMV0pLCBkdmlldy5zZXRVaW50OCgyLCBieXRlc1twICsgMl0pLCBkdmlldy5zZXRVaW50OCgzLCBieXRlc1twICsgM10pO1xuICB2YXIgdGRlcHRoID0gZHZpZXcuZ2V0SW50MzIoMCwgdHJ1ZSk7XG4gIHAgPSBwICsgNDtcbiAgLypcclxuICBuZXh0LCByZWFkIHRoZSBudW1iZXIgb2YgdHJlZXMgaW4gdGhlIGNhc2NhZGU6IGFub3RoZXIgMzItYml0IHNpZ25lZCBpbnRlZ2VyXHJcbiAgKi9cblxuICBkdmlldy5zZXRVaW50OCgwLCBieXRlc1twICsgMF0pLCBkdmlldy5zZXRVaW50OCgxLCBieXRlc1twICsgMV0pLCBkdmlldy5zZXRVaW50OCgyLCBieXRlc1twICsgMl0pLCBkdmlldy5zZXRVaW50OCgzLCBieXRlc1twICsgM10pO1xuICB2YXIgbnRyZWVzID0gZHZpZXcuZ2V0SW50MzIoMCwgdHJ1ZSk7XG4gIHAgPSBwICsgNDtcbiAgLypcclxuICByZWFkIHRoZSBhY3R1YWwgdHJlZXMgYW5kIGNhc2NhZGUgdGhyZXNob2xkc1xyXG4gICovXG5cbiAgdmFyIHRjb2Rlc19scyA9IFtdO1xuICB2YXIgdHByZWRzX2xzID0gW107XG4gIHZhciB0aHJlc2hfbHMgPSBbXTtcblxuICBmb3IgKHZhciB0ID0gMDsgdCA8IG50cmVlczsgKyt0KSB7XG4gICAgLy8gcmVhZCB0aGUgYmluYXJ5IHRlc3RzIHBsYWNlZCBpbiBpbnRlcm5hbCB0cmVlIG5vZGVzXG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGNvZGVzX2xzLCBbMCwgMCwgMCwgMF0pO1xuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRjb2Rlc19scywgYnl0ZXMuc2xpY2UocCwgcCArIDQgKiBNYXRoLnBvdygyLCB0ZGVwdGgpIC0gNCkpO1xuICAgIHAgPSBwICsgNCAqIE1hdGgucG93KDIsIHRkZXB0aCkgLSA0OyAvLyByZWFkIHRoZSBwcmVkaWN0aW9uIGluIHRoZSBsZWFmIG5vZGVzIG9mIHRoZSB0cmVlXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgucG93KDIsIHRkZXB0aCk7ICsraSkge1xuICAgICAgZHZpZXcuc2V0VWludDgoMCwgYnl0ZXNbcCArIDBdKSwgZHZpZXcuc2V0VWludDgoMSwgYnl0ZXNbcCArIDFdKSwgZHZpZXcuc2V0VWludDgoMiwgYnl0ZXNbcCArIDJdKSwgZHZpZXcuc2V0VWludDgoMywgYnl0ZXNbcCArIDNdKTtcbiAgICAgIHRwcmVkc19scy5wdXNoKGR2aWV3LmdldEZsb2F0MzIoMCwgdHJ1ZSkpO1xuICAgICAgcCA9IHAgKyA0O1xuICAgIH0gLy8gcmVhZCB0aGUgdGhyZXNob2xkXG5cblxuICAgIGR2aWV3LnNldFVpbnQ4KDAsIGJ5dGVzW3AgKyAwXSksIGR2aWV3LnNldFVpbnQ4KDEsIGJ5dGVzW3AgKyAxXSksIGR2aWV3LnNldFVpbnQ4KDIsIGJ5dGVzW3AgKyAyXSksIGR2aWV3LnNldFVpbnQ4KDMsIGJ5dGVzW3AgKyAzXSk7XG4gICAgdGhyZXNoX2xzLnB1c2goZHZpZXcuZ2V0RmxvYXQzMigwLCB0cnVlKSk7XG4gICAgcCA9IHAgKyA0O1xuICB9XG5cbiAgdmFyIHRjb2RlcyA9IG5ldyBJbnQ4QXJyYXkodGNvZGVzX2xzKTtcbiAgdmFyIHRwcmVkcyA9IG5ldyBGbG9hdDMyQXJyYXkodHByZWRzX2xzKTtcbiAgdmFyIHRocmVzaCA9IG5ldyBGbG9hdDMyQXJyYXkodGhyZXNoX2xzKTtcbiAgLypcclxuICBjb25zdHJ1Y3QgdGhlIGNsYXNzaWZpY2F0aW9uIGZ1bmN0aW9uIGZyb20gdGhlIHJlYWQgZGF0YVxyXG4gICovXG5cbiAgZnVuY3Rpb24gY2xhc3NpZnlfcmVnaW9uKHIsIGMsIHMsIHBpeGVscywgbGRpbSkge1xuICAgIHIgPSAyNTYgKiByO1xuICAgIGMgPSAyNTYgKiBjO1xuICAgIHZhciByb290ID0gMDtcbiAgICB2YXIgbyA9IDAuMDtcbiAgICB2YXIgcG93MnRkZXB0aCA9IE1hdGgucG93KDIsIHRkZXB0aCkgPj4gMDsgLy8gJz4+MCcgdHJhbnNmb3JtcyB0aGlzIG51bWJlciB0byBpbnRcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBudHJlZXM7ICsrX2kpIHtcbiAgICAgIHZhciBpZHggPSAxO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRkZXB0aDsgKytqKSB7XG4gICAgICAgIC8vIHdlIHVzZSAnPj4gOCcgaGVyZSB0byBwZXJmb3JtIGFuIGludGVnZXIgZGl2aXNpb246IHRoaXMgc2VlbXMgaW1wb3J0YW50IGZvciBwZXJmb3JtYW5jZVxuICAgICAgICBpZHggPSAyICogaWR4ICsgKHBpeGVsc1sociArIHRjb2Rlc1tyb290ICsgNCAqIGlkeCArIDBdICogcyA+PiA4KSAqIGxkaW0gKyAoYyArIHRjb2Rlc1tyb290ICsgNCAqIGlkeCArIDFdICogcyA+PiA4KV0gPD0gcGl4ZWxzWyhyICsgdGNvZGVzW3Jvb3QgKyA0ICogaWR4ICsgMl0gKiBzID4+IDgpICogbGRpbSArIChjICsgdGNvZGVzW3Jvb3QgKyA0ICogaWR4ICsgM10gKiBzID4+IDgpXSk7XG4gICAgICB9XG5cbiAgICAgIG8gPSBvICsgdHByZWRzW3BvdzJ0ZGVwdGggKiBfaSArIGlkeCAtIHBvdzJ0ZGVwdGhdO1xuICAgICAgaWYgKG8gPD0gdGhyZXNoW19pXSkgcmV0dXJuIC0xO1xuICAgICAgcm9vdCArPSA0ICogcG93MnRkZXB0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gbyAtIHRocmVzaFtudHJlZXMgLSAxXTtcbiAgfVxuICAvKlxyXG4gIHdlJ3JlIGRvbmVcclxuICAqL1xuXG5cbiAgcmV0dXJuIGNsYXNzaWZ5X3JlZ2lvbjtcbn07XG5cbnBpY28ucnVuX2Nhc2NhZGUgPSBmdW5jdGlvbiAoaW1hZ2UsIGNsYXNzaWZ5X3JlZ2lvbiwgcGFyYW1zKSB7XG4gIHZhciBwaXhlbHMgPSBpbWFnZS5waXhlbHM7XG4gIHZhciBucm93cyA9IGltYWdlLm5yb3dzO1xuICB2YXIgbmNvbHMgPSBpbWFnZS5uY29scztcbiAgdmFyIGxkaW0gPSBpbWFnZS5sZGltO1xuICB2YXIgc2hpZnRmYWN0b3IgPSBwYXJhbXMuc2hpZnRmYWN0b3I7XG4gIHZhciBtaW5zaXplID0gcGFyYW1zLm1pbnNpemU7XG4gIHZhciBtYXhzaXplID0gcGFyYW1zLm1heHNpemU7XG4gIHZhciBzY2FsZWZhY3RvciA9IHBhcmFtcy5zY2FsZWZhY3RvcjtcbiAgdmFyIHNjYWxlID0gbWluc2l6ZTtcbiAgdmFyIGRldGVjdGlvbnMgPSBbXTtcblxuICB3aGlsZSAoc2NhbGUgPD0gbWF4c2l6ZSkge1xuICAgIHZhciBzdGVwID0gTWF0aC5tYXgoc2hpZnRmYWN0b3IgKiBzY2FsZSwgMSkgPj4gMDsgLy8gJz4+MCcgdHJhbnNmb3JtcyB0aGlzIG51bWJlciB0byBpbnRcblxuICAgIHZhciBvZmZzZXQgPSBzY2FsZSAvIDIgKyAxID4+IDA7XG5cbiAgICBmb3IgKHZhciByID0gb2Zmc2V0OyByIDw9IG5yb3dzIC0gb2Zmc2V0OyByICs9IHN0ZXApIHtcbiAgICAgIGZvciAodmFyIGMgPSBvZmZzZXQ7IGMgPD0gbmNvbHMgLSBvZmZzZXQ7IGMgKz0gc3RlcCkge1xuICAgICAgICB2YXIgcSA9IGNsYXNzaWZ5X3JlZ2lvbihyLCBjLCBzY2FsZSwgcGl4ZWxzLCBsZGltKTtcbiAgICAgICAgaWYgKHEgPiAwLjApIGRldGVjdGlvbnMucHVzaChbciwgYywgc2NhbGUsIHFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2FsZSA9IHNjYWxlICogc2NhbGVmYWN0b3I7XG4gIH1cblxuICByZXR1cm4gZGV0ZWN0aW9ucztcbn07XG5cbnBpY28uY2x1c3Rlcl9kZXRlY3Rpb25zID0gZnVuY3Rpb24gKGRldHMsIGlvdXRocmVzaG9sZCkge1xuICAvKlxyXG4gIHNvcnQgZGV0ZWN0aW9ucyBieSB0aGVpciBzY29yZVxyXG4gICovXG4gIGRldHMgPSBkZXRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYlszXSAtIGFbM107XG4gIH0pO1xuICAvKlxyXG4gIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIGludGVyc2VjdGlvbiBvdmVyIHVuaW9uIGZvciB0d28gZGV0ZWN0aW9uc1xyXG4gICovXG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlX2lvdShkZXQxLCBkZXQyKSB7XG4gICAgLy8gdW5wYWNrIHRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiBlYWNoIGRldGVjdGlvblxuICAgIHZhciByMSA9IGRldDFbMF0sXG4gICAgICAgIGMxID0gZGV0MVsxXSxcbiAgICAgICAgczEgPSBkZXQxWzJdO1xuICAgIHZhciByMiA9IGRldDJbMF0sXG4gICAgICAgIGMyID0gZGV0MlsxXSxcbiAgICAgICAgczIgPSBkZXQyWzJdOyAvLyBjYWxjdWxhdGUgZGV0ZWN0aW9uIG92ZXJsYXAgaW4gZWFjaCBkaW1lbnNpb25cblxuICAgIHZhciBvdmVyciA9IE1hdGgubWF4KDAsIE1hdGgubWluKHIxICsgczEgLyAyLCByMiArIHMyIC8gMikgLSBNYXRoLm1heChyMSAtIHMxIC8gMiwgcjIgLSBzMiAvIDIpKTtcbiAgICB2YXIgb3ZlcmMgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjMSArIHMxIC8gMiwgYzIgKyBzMiAvIDIpIC0gTWF0aC5tYXgoYzEgLSBzMSAvIDIsIGMyIC0gczIgLyAyKSk7IC8vIGNhbGN1bGF0ZSBhbmQgcmV0dXJuIElvVVxuXG4gICAgcmV0dXJuIG92ZXJyICogb3ZlcmMgLyAoczEgKiBzMSArIHMyICogczIgLSBvdmVyciAqIG92ZXJjKTtcbiAgfVxuICAvKlxyXG4gIGRvIGNsdXN0ZXJpbmcgdGhyb3VnaCBub24tbWF4aW11bSBzdXBwcmVzc2lvblxyXG4gICovXG5cblxuICB2YXIgYXNzaWdubWVudHMgPSBuZXcgQXJyYXkoZGV0cy5sZW5ndGgpLmZpbGwoMCk7XG4gIHZhciBjbHVzdGVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGV0cy5sZW5ndGg7ICsraSkge1xuICAgIC8vIGlzIHRoaXMgZGV0ZWN0aW9uIGFzc2lnbmVkIHRvIGEgY2x1c3Rlcj9cbiAgICBpZiAoYXNzaWdubWVudHNbaV0gPT0gMCkge1xuICAgICAgLy8gaXQgaXMgbm90OlxuICAgICAgLy8gbm93IHdlIG1ha2UgYSBjbHVzdGVyIG91dCBvZiBpdCBhbmQgc2VlIHdoZXRoZXIgc29tZSBvdGhlciBkZXRlY3Rpb25zIGJlbG9uZyB0byBpdFxuICAgICAgdmFyIHIgPSAwLjAsXG4gICAgICAgICAgYyA9IDAuMCxcbiAgICAgICAgICBzID0gMC4wLFxuICAgICAgICAgIHEgPSAwLjAsXG4gICAgICAgICAgbiA9IDA7XG5cbiAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgZGV0cy5sZW5ndGg7ICsraikge1xuICAgICAgICBpZiAoY2FsY3VsYXRlX2lvdShkZXRzW2ldLCBkZXRzW2pdKSA+IGlvdXRocmVzaG9sZCkge1xuICAgICAgICAgIGFzc2lnbm1lbnRzW2pdID0gMTtcbiAgICAgICAgICByID0gciArIGRldHNbal1bMF07XG4gICAgICAgICAgYyA9IGMgKyBkZXRzW2pdWzFdO1xuICAgICAgICAgIHMgPSBzICsgZGV0c1tqXVsyXTtcbiAgICAgICAgICBxID0gcSArIGRldHNbal1bM107XG4gICAgICAgICAgbiA9IG4gKyAxO1xuICAgICAgICB9XG4gICAgICB9IC8vIG1ha2UgYSBjbHVzdGVyIHJlcHJlc2VudGF0aXZlXG5cblxuICAgICAgY2x1c3RlcnMucHVzaChbciAvIG4sIGMgLyBuLCBzIC8gbiwgcV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbHVzdGVycztcbn07XG5cbnBpY28uaW5zdGFudGlhdGVfZGV0ZWN0aW9uX21lbW9yeSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIC8qXHJcbiAgaW5pdGlhbGl6ZSBhIGNpcmN1bGFyIGJ1ZmZlciBvZiBgc2l6ZWAgZWxlbWVudHNcclxuICAqL1xuICB2YXIgbiA9IDA7XG4gIHZhciBtZW1vcnkgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgIG1lbW9yeS5wdXNoKFtdKTtcbiAgfVxuICAvKlxyXG4gIGJ1aWxkIGEgZnVuY3Rpb24gdGhhdDpcclxuICAoMSkgaW5zZXJ0cyB0aGUgY3VycmVudCBmcmFtZSdzIGRldGVjdGlvbnMgaW50byB0aGUgYnVmZmVyO1xyXG4gICgyKSBtZXJnZXMgYWxsIGRldGVjdGlvbnMgZnJvbSB0aGUgbGFzdCBgc2l6ZWAgZnJhbWVzIGFuZCByZXR1cm5zIHRoZW1cclxuICAqL1xuXG5cbiAgZnVuY3Rpb24gdXBkYXRlX21lbW9yeShkZXRzKSB7XG4gICAgbWVtb3J5W25dID0gZGV0cztcbiAgICBuID0gKG4gKyAxKSAlIG1lbW9yeS5sZW5ndGg7XG4gICAgZGV0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbWVtb3J5Lmxlbmd0aDsgKytfaTIpIHtcbiAgICAgIGRldHMgPSBkZXRzLmNvbmNhdChtZW1vcnlbX2kyXSk7XG4gICAgfSAvL1xuXG5cbiAgICByZXR1cm4gZGV0cztcbiAgfVxuICAvKlxyXG4gIHdlJ3JlIGRvbmVcclxuICAqL1xuXG5cbiAgcmV0dXJuIHVwZGF0ZV9tZW1vcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwaWNvOyIsImltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5XCI7XG5cbi8qIFRoaXMgbGlicmFyeSBpcyByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UsIGNvbnRhY3QgQHRlaG5va3YgZm9yIG1vcmUgZGV0YWlscyAqL1xudmFyIGxwbG9jID0ge307XG5cbmxwbG9jLnVucGFja19sb2NhbGl6ZXIgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgLy9cbiAgdmFyIGR2aWV3ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig0KSk7XG4gIHZhciBwID0gMDtcbiAgLypcclxuICByZWFkIHRoZSBudW1iZXIgb2Ygc3RhZ2VzLCBzY2FsZSBtdWx0aXBsaWVyIChhcHBsaWVkIGFmdGVyIGVhY2ggc3RhZ2UpLFxyXG4gIG51bWJlciBvZiB0cmVlcyBwZXIgc3RhZ2UgYW5kIGRlcHRoIG9mIGVhY2ggdHJlZVxyXG4gICovXG5cbiAgZHZpZXcuc2V0VWludDgoMCwgYnl0ZXNbcCArIDBdKSwgZHZpZXcuc2V0VWludDgoMSwgYnl0ZXNbcCArIDFdKSwgZHZpZXcuc2V0VWludDgoMiwgYnl0ZXNbcCArIDJdKSwgZHZpZXcuc2V0VWludDgoMywgYnl0ZXNbcCArIDNdKTtcbiAgdmFyIG5zdGFnZXMgPSBkdmlldy5nZXRJbnQzMigwLCB0cnVlKTtcbiAgcCA9IHAgKyA0O1xuICBkdmlldy5zZXRVaW50OCgwLCBieXRlc1twICsgMF0pLCBkdmlldy5zZXRVaW50OCgxLCBieXRlc1twICsgMV0pLCBkdmlldy5zZXRVaW50OCgyLCBieXRlc1twICsgMl0pLCBkdmlldy5zZXRVaW50OCgzLCBieXRlc1twICsgM10pO1xuICB2YXIgc2NhbGVtdWwgPSBkdmlldy5nZXRGbG9hdDMyKDAsIHRydWUpO1xuICBwID0gcCArIDQ7XG4gIGR2aWV3LnNldFVpbnQ4KDAsIGJ5dGVzW3AgKyAwXSksIGR2aWV3LnNldFVpbnQ4KDEsIGJ5dGVzW3AgKyAxXSksIGR2aWV3LnNldFVpbnQ4KDIsIGJ5dGVzW3AgKyAyXSksIGR2aWV3LnNldFVpbnQ4KDMsIGJ5dGVzW3AgKyAzXSk7XG4gIHZhciBudHJlZXNwZXJzdGFnZSA9IGR2aWV3LmdldEludDMyKDAsIHRydWUpO1xuICBwID0gcCArIDQ7XG4gIGR2aWV3LnNldFVpbnQ4KDAsIGJ5dGVzW3AgKyAwXSksIGR2aWV3LnNldFVpbnQ4KDEsIGJ5dGVzW3AgKyAxXSksIGR2aWV3LnNldFVpbnQ4KDIsIGJ5dGVzW3AgKyAyXSksIGR2aWV3LnNldFVpbnQ4KDMsIGJ5dGVzW3AgKyAzXSk7XG4gIHZhciB0ZGVwdGggPSBkdmlldy5nZXRJbnQzMigwLCB0cnVlKTtcbiAgcCA9IHAgKyA0O1xuICAvKlxyXG4gIHVucGFjayB0aGUgdHJlZXNcclxuICAqL1xuXG4gIHZhciB0Y29kZXNfbHMgPSBbXTtcbiAgdmFyIHRwcmVkc19scyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnN0YWdlczsgKytpKSB7XG4gICAgLy8gcmVhZCB0aGUgdHJlZXMgZm9yIHRoaXMgc3RhZ2VcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG50cmVlc3BlcnN0YWdlOyArK2opIHtcbiAgICAgIC8vIGJpbmFyeSB0ZXN0cyAod2UgY2FuIHJlYWQgYWxsIG9mIHRoZW0gYXQgb25jZSlcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRjb2Rlc19scywgYnl0ZXMuc2xpY2UocCwgcCArIDQgKiBNYXRoLnBvdygyLCB0ZGVwdGgpIC0gNCkpO1xuICAgICAgcCA9IHAgKyA0ICogTWF0aC5wb3coMiwgdGRlcHRoKSAtIDQ7IC8vIHJlYWQgdGhlIHByZWRpY3Rpb24gaW4gdGhlIGxlYWYgbm9kZXMgb2YgdGhlIHRyZWVcblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBNYXRoLnBvdygyLCB0ZGVwdGgpOyArK2spIHtcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCAyOyArK2wpIHtcbiAgICAgICAgICBkdmlldy5zZXRVaW50OCgwLCBieXRlc1twICsgMF0pLCBkdmlldy5zZXRVaW50OCgxLCBieXRlc1twICsgMV0pLCBkdmlldy5zZXRVaW50OCgyLCBieXRlc1twICsgMl0pLCBkdmlldy5zZXRVaW50OCgzLCBieXRlc1twICsgM10pO1xuICAgICAgICAgIHRwcmVkc19scy5wdXNoKGR2aWV3LmdldEZsb2F0MzIoMCwgdHJ1ZSkpO1xuICAgICAgICAgIHAgPSBwICsgNDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB0Y29kZXMgPSBuZXcgSW50OEFycmF5KHRjb2Rlc19scyk7XG4gIHZhciB0cHJlZHMgPSBuZXcgRmxvYXQzMkFycmF5KHRwcmVkc19scyk7XG4gIC8qXHJcbiAgY29uc3RydWN0IHRoZSBsb2NhdGlvbiBlc3RpbWF0b24gZnVuY3Rpb25cclxuICAqL1xuXG4gIGZ1bmN0aW9uIGxvY19mdW4ociwgYywgcywgcGl4ZWxzLCBucm93cywgbmNvbHMsIGxkaW0pIHtcbiAgICB2YXIgcm9vdCA9IDA7XG4gICAgdmFyIHBvdzJ0ZGVwdGggPSBNYXRoLnBvdygyLCB0ZGVwdGgpID4+IDA7IC8vICc+PjAnIHRyYW5zZm9ybXMgdGhpcyBudW1iZXIgdG8gaW50XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbnN0YWdlczsgKytfaSkge1xuICAgICAgdmFyIGRyID0gMC4wLFxuICAgICAgICAgIGRjID0gMC4wO1xuXG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbnRyZWVzcGVyc3RhZ2U7ICsrX2opIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IHRkZXB0aDsgKytfaykge1xuICAgICAgICAgIHZhciByMSA9IE1hdGgubWluKG5yb3dzIC0gMSwgTWF0aC5tYXgoMCwgMjU2ICogciArIHRjb2Rlc1tyb290ICsgNCAqIGlkeCArIDBdICogcyA+PiA4KSk7XG4gICAgICAgICAgdmFyIGMxID0gTWF0aC5taW4obmNvbHMgLSAxLCBNYXRoLm1heCgwLCAyNTYgKiBjICsgdGNvZGVzW3Jvb3QgKyA0ICogaWR4ICsgMV0gKiBzID4+IDgpKTtcbiAgICAgICAgICB2YXIgcjIgPSBNYXRoLm1pbihucm93cyAtIDEsIE1hdGgubWF4KDAsIDI1NiAqIHIgKyB0Y29kZXNbcm9vdCArIDQgKiBpZHggKyAyXSAqIHMgPj4gOCkpO1xuICAgICAgICAgIHZhciBjMiA9IE1hdGgubWluKG5jb2xzIC0gMSwgTWF0aC5tYXgoMCwgMjU2ICogYyArIHRjb2Rlc1tyb290ICsgNCAqIGlkeCArIDNdICogcyA+PiA4KSk7XG4gICAgICAgICAgaWR4ID0gMiAqIGlkeCArIDEgKyAocGl4ZWxzW3IxICogbGRpbSArIGMxXSA+IHBpeGVsc1tyMiAqIGxkaW0gKyBjMl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGx1dGlkeCA9IDIgKiAobnRyZWVzcGVyc3RhZ2UgKiBwb3cydGRlcHRoICogX2kgKyBwb3cydGRlcHRoICogX2ogKyBpZHggLSAocG93MnRkZXB0aCAtIDEpKTtcbiAgICAgICAgZHIgKz0gdHByZWRzW2x1dGlkeCArIDBdO1xuICAgICAgICBkYyArPSB0cHJlZHNbbHV0aWR4ICsgMV07XG4gICAgICAgIHJvb3QgKz0gNCAqIHBvdzJ0ZGVwdGggLSA0O1xuICAgICAgfVxuXG4gICAgICByID0gciArIGRyICogcztcbiAgICAgIGMgPSBjICsgZGMgKiBzO1xuICAgICAgcyA9IHMgKiBzY2FsZW11bDtcbiAgICB9XG5cbiAgICByZXR1cm4gW3IsIGNdO1xuICB9XG4gIC8qXHJcbiAgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIHJhbmRvbSBwZXJ0dXJiYXRpb25zIHRvIHRoZSBkZWZhdWx0IHJlY3RhbmdsZSAociwgYywgcylcclxuICAqL1xuXG5cbiAgZnVuY3Rpb24gbG9jX2Z1bl93aXRoX3BlcnR1cmJzKHIsIGMsIHMsIG5wZXJ0dXJicywgaW1hZ2UpIHtcbiAgICB2YXIgcm93cyA9IFtdLFxuICAgICAgICBjb2xzID0gW107XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBucGVydHVyYnM7ICsrX2kyKSB7XG4gICAgICB2YXIgX3MgPSBzICogKDAuOTI1ICsgMC4xNSAqIE1hdGgucmFuZG9tKCkpO1xuXG4gICAgICB2YXIgX3IgPSByICsgcyAqIDAuMTUgKiAoMC41IC0gTWF0aC5yYW5kb20oKSk7XG5cbiAgICAgIHZhciBfYyA9IGMgKyBzICogMC4xNSAqICgwLjUgLSBNYXRoLnJhbmRvbSgpKTtcblxuICAgICAgdmFyIF9sb2NfZnVuID0gbG9jX2Z1bihfciwgX2MsIF9zLCBpbWFnZS5waXhlbHMsIGltYWdlLm5yb3dzLCBpbWFnZS5uY29scywgaW1hZ2UubGRpbSk7XG5cbiAgICAgIHZhciBfbG9jX2Z1bjIgPSBfc2xpY2VkVG9BcnJheShfbG9jX2Z1biwgMik7XG5cbiAgICAgIF9yID0gX2xvY19mdW4yWzBdO1xuICAgICAgX2MgPSBfbG9jX2Z1bjJbMV07XG4gICAgICByb3dzLnB1c2goX3IpO1xuICAgICAgY29scy5wdXNoKF9jKTtcbiAgICB9IC8vIHJldHVybiB0aGUgbWVkaWFuIGFsb25nIGVhY2ggYXhpc1xuXG5cbiAgICByb3dzLnNvcnQoKTtcbiAgICBjb2xzLnNvcnQoKTtcbiAgICByZXR1cm4gW3Jvd3NbTWF0aC5yb3VuZChucGVydHVyYnMgLyAyKV0sIGNvbHNbTWF0aC5yb3VuZChucGVydHVyYnMgLyAyKV1dO1xuICB9XG4gIC8qXHJcbiAgd2UncmUgZG9uZVxyXG4gICovXG5cblxuICByZXR1cm4gbG9jX2Z1bl93aXRoX3BlcnR1cmJzO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbHBsb2M7IiwiZXhwb3J0IGZ1bmN0aW9uIHJnYmFfdG9fZ3JheXNjYWxlKHJnYmEsIG5yb3dzLCBuY29scykge1xuICB2YXIgZ3JheSA9IG5ldyBVaW50OEFycmF5KG5yb3dzICogbmNvbHMpO1xuXG4gIGZvciAodmFyIHIgPSAwOyByIDwgbnJvd3M7ICsrcikge1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbmNvbHM7ICsrYykge1xuICAgICAgLy8gZ3JheSA9IDAuMipyZWQgKyAwLjcqZ3JlZW4gKyAwLjEqYmx1ZVxuICAgICAgZ3JheVtyICogbmNvbHMgKyBjXSA9ICgyICogcmdiYVtyICogNCAqIG5jb2xzICsgNCAqIGMgKyAwXSArIDcgKiByZ2JhW3IgKiA0ICogbmNvbHMgKyA0ICogYyArIDFdICsgMSAqIHJnYmFbciAqIDQgKiBuY29scyArIDQgKiBjICsgMl0pIC8gMTA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdyYXk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FudmFzX3RvX2ltYWdlKGNhbnZhcykge1xuICB2YXIgaW1nID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuICByZXR1cm4gaW1nO1xufSIsImltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBwaWNvIGZyb20gXCIuLi8uLi8uLi9jb21wb25lbnRzL3BpY28vcGljby5qc1wiO1xuaW1wb3J0IGxwbG9jIGZyb20gXCIuLi8uLi8uLi9jb21wb25lbnRzL3BpY28vbHBsb2MuanNcIjtcbmltcG9ydCB7IHJnYmFfdG9fZ3JheXNjYWxlIH0gZnJvbSBcIi4uLy4uLy4uL2NvbXBvbmVudHMvcGljby91dGlsaXR5L2luZGV4LmpzXCI7XG5cbmZ1bmN0aW9uIFBpY28ocHJvcHMpIHtcbiAgdmFyIHZpZGVvID0gcHJvcHMudmlkZW8sXG4gICAgICBfcHJvcHMkc2NvcmUgPSBwcm9wcy5zY29yZSxcbiAgICAgIHNjb3JlID0gX3Byb3BzJHNjb3JlID09PSB2b2lkIDAgPyAxMDAgOiBfcHJvcHMkc2NvcmU7XG4gIHZhciBjdHhfcmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgc2NvcmVfcmVmID0gdXNlUmVmKHNjb3JlKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBzY29yZV9yZWYuY3VycmVudCA9IHNjb3JlO1xuICB9LCBbc2NvcmVdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIHZhciBjYW5jZWwgPSBmYWxzZTtcbiAgICAgIHZhciBjdHggPSBjdHhfcmVmLmN1cnJlbnQuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgdmFyIHVwZGF0ZV9tZW1vcnkgPSBwaWNvLmluc3RhbnRpYXRlX2RldGVjdGlvbl9tZW1vcnkoNSk7XG4gICAgICB2YXIgZmV0Y2hfcHVwbG9jID0gZmV0Y2goXCIuL2RhdGEvcHVwbG9jLmJpblwiKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbHBsb2MudW5wYWNrX2xvY2FsaXplcihuZXcgSW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgfSk7XG4gICAgICB2YXIgZmV0Y2hfZmFjZSA9IGZldGNoKFwiLi9kYXRhL2ZhY2VmaW5kZXJcIikudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHBpY28udW5wYWNrX2Nhc2NhZGUobmV3IEludDhBcnJheShidWZmZXIpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgc2hpZnRmYWN0b3I6IDAuMSxcbiAgICAgICAgLy8gbW92ZSB0aGUgZGV0ZWN0aW9uIHdpbmRvdyBieSAxMCUgb2YgaXRzIHNpemVcbiAgICAgICAgbWluc2l6ZTogMTAwLFxuICAgICAgICAvLyBtaW5pbXVtIHNpemUgb2YgYSBmYWNlXG4gICAgICAgIG1heHNpemU6IDEwMDAsXG4gICAgICAgIC8vIG1heGltdW0gc2l6ZSBvZiBhIGZhY2VcbiAgICAgICAgc2NhbGVmYWN0b3I6IDEuMSAvLyBmb3IgbXVsdGlzY2FsZSBwcm9jZXNzaW5nOiByZXNpemUgdGhlIGRldGVjdGlvbiB3aW5kb3cgYnkgMTAlIHdoZW4gbW92aW5nIHRvIHRoZSBoaWdoZXIgc2NhbGVcblxuICAgICAgfTtcbiAgICAgIFByb21pc2UuYWxsKFtmZXRjaF9mYWNlLCBmZXRjaF9wdXBsb2NdKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgZmFjZWZpbmRlcl9jbGFzc2lmeV9yZWdpb24gPSBfcmVmMlswXSxcbiAgICAgICAgICAgIGRvX3B1cGxvYyA9IF9yZWYyWzFdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFZpZGVvRnJhbWUoKSB7XG4gICAgICAgICAgaWYgKGNhbmNlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodmlkZW8sIDAsIDApO1xuICAgICAgICAgIHZhciByZ2JhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCA2NDAsIDQ4MCkuZGF0YTtcbiAgICAgICAgICB2YXIgaW1hZ2UgPSB7XG4gICAgICAgICAgICBwaXhlbHM6IHJnYmFfdG9fZ3JheXNjYWxlKHJnYmEsIDQ4MCwgNjQwKSxcbiAgICAgICAgICAgIG5yb3dzOiA0ODAsXG4gICAgICAgICAgICBuY29sczogNjQwLFxuICAgICAgICAgICAgbGRpbTogNjQwXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgZGV0cyA9IHBpY28ucnVuX2Nhc2NhZGUoaW1hZ2UsIGZhY2VmaW5kZXJfY2xhc3NpZnlfcmVnaW9uLCBwYXJhbXMpO1xuICAgICAgICAgIGRldHMgPSB1cGRhdGVfbWVtb3J5KGRldHMpO1xuICAgICAgICAgIGRldHMgPSBwaWNvLmNsdXN0ZXJfZGV0ZWN0aW9ucyhkZXRzLCAwLjIpOyAvLyBzZXQgSW9VIHRocmVzaG9sZCB0byAwLjJcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGRldHNbaV1bM10gPiBzY29yZV9yZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIGN0eC5hcmMoZGV0c1tpXVsxXSwgZGV0c1tpXVswXSwgZGV0c1tpXVsyXSAvIDIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAzO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgIHZhciByID0gZGV0c1tpXVswXSAtIDAuMDc1ICogZGV0c1tpXVsyXTtcbiAgICAgICAgICAgICAgdmFyIGMgPSBkZXRzW2ldWzFdIC0gMC4xNzUgKiBkZXRzW2ldWzJdO1xuICAgICAgICAgICAgICB2YXIgcyA9IDAuMzUgKiBkZXRzW2ldWzJdO1xuXG4gICAgICAgICAgICAgIHZhciBfZG9fcHVwbG9jID0gZG9fcHVwbG9jKHIsIGMsIHMsIDYzLCBpbWFnZSk7XG5cbiAgICAgICAgICAgICAgdmFyIF9kb19wdXBsb2MyID0gX3NsaWNlZFRvQXJyYXkoX2RvX3B1cGxvYywgMik7XG5cbiAgICAgICAgICAgICAgciA9IF9kb19wdXBsb2MyWzBdO1xuICAgICAgICAgICAgICBjID0gX2RvX3B1cGxvYzJbMV07XG5cbiAgICAgICAgICAgICAgaWYgKHIgPj0gMCAmJiBjID49IDApIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhjLCByLCAxLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAzO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmVkXCI7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgciA9IGRldHNbaV1bMF0gLSAwLjA3NSAqIGRldHNbaV1bMl07XG4gICAgICAgICAgICAgIGMgPSBkZXRzW2ldWzFdICsgMC4xNzUgKiBkZXRzW2ldWzJdO1xuICAgICAgICAgICAgICBzID0gMC4zNSAqIGRldHNbaV1bMl07XG5cbiAgICAgICAgICAgICAgdmFyIF9kb19wdXBsb2MzID0gZG9fcHVwbG9jKHIsIGMsIHMsIDYzLCBpbWFnZSk7XG5cbiAgICAgICAgICAgICAgdmFyIF9kb19wdXBsb2M0ID0gX3NsaWNlZFRvQXJyYXkoX2RvX3B1cGxvYzMsIDIpO1xuXG4gICAgICAgICAgICAgIHIgPSBfZG9fcHVwbG9jNFswXTtcbiAgICAgICAgICAgICAgYyA9IF9kb19wdXBsb2M0WzFdO1xuXG4gICAgICAgICAgICAgIGlmIChyID49IDAgJiYgYyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoYywgciwgMSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMztcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VmlkZW9GcmFtZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0VmlkZW9GcmFtZSgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFt2aWRlb10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwge1xuICAgIHdpZHRoOiA2NDAsXG4gICAgaGVpZ2h0OiA0ODAsXG4gICAgcmVmOiBjdHhfcmVmXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKFBpY28pOyIsImltcG9ydCBfQmFja1RvcCBmcm9tIFwiYW50ZC9saWIvYmFjay10b3BcIjtcbmltcG9ydCBfQ2FyZCBmcm9tIFwiYW50ZC9saWIvY2FyZFwiO1xuaW1wb3J0IF9TbGlkZXIgZnJvbSBcImFudGQvbGliL3NsaWRlclwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBXZWJSVEMgZnJvbSBcIi4vd2ViLXJ0Yy5qc1wiO1xuaW1wb3J0IFBpY29EZXRlY3QgZnJvbSBcIi4vcGljby1kZXRlY3QuanNcIjtcblxuZnVuY3Rpb24gRmFjZURldGVjdCgpIHtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKDEwMCksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIHNjb3JlID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldFNjb3JlID0gX3VzZVN0YXRlMlsxXTtcblxuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKCksXG4gICAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMiksXG4gICAgICB2aWRlbyA9IF91c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRWaWRlbyA9IF91c2VTdGF0ZTRbMV07XG5cbiAgdmFyIG9uQWZ0ZXJDaGFuZ2UgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsKSB7XG4gICAgc2V0SW1nKFtdKTtcbiAgICBzZXRTY29yZSh2YWwpO1xuICB9LCBbXSk7XG4gIHZhciBvbmNhbnBsYXkgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmlkZW8pIHtcbiAgICBzZXRWaWRlbyh2aWRlbyk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChfQ2FyZCwge1xuICAgIHN0eWxlOiB7XG4gICAgICBtYXJnaW5Cb3R0b206IDI0XG4gICAgfVxuICB9LCBcIkFjY3VyYWN5OlwiLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChfU2xpZGVyLCB7XG4gICAgZGVmYXVsdFZhbHVlOiBzY29yZSxcbiAgICBtYXg6IDUwMCxcbiAgICBtaW46IDUwLFxuICAgIG1hcmtzOiB7XG4gICAgICA1MDA6IFwiNTAwXCIsXG4gICAgICA1MDogXCI1MFwiXG4gICAgfSxcbiAgICBvbkFmdGVyQ2hhbmdlOiBvbkFmdGVyQ2hhbmdlLFxuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogMjAwXG4gICAgfVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBtYXJnaW5Ub3A6IDQwXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChXZWJSVEMsIHtcbiAgICBvbmNhbnBsYXk6IG9uY2FucGxheVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUGljb0RldGVjdCwge1xuICAgIHZpZGVvOiB2aWRlbyxcbiAgICBzY29yZTogc2NvcmVcbiAgfSkpKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX0JhY2tUb3AsIG51bGwpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhGYWNlRGV0ZWN0KTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///634\n')}}]);